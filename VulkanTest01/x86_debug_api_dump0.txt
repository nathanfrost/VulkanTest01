t{0} f{0} vkCreateInstance(pCreateInfo = 0x20f76c, pAllocator = 0x0, *pInstance
= 0x71e868) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    pNext = 0x20f78c
    flags = 0x0
    pApplicationInfo = 0x20f964
    enabledLayerCount = 0x7
    ppEnabledLayerNames = 0x6ef658
    enabledExtensionCount = 0x3
    ppEnabledExtensionNames = 0x6f54e8
     pApplicationInfo:
      sType = VK_STRUCTURE_TYPE_APPLICATION_INFO
      pNext = 0x0
      pApplicationName = Hello Triangle
      applicationVersion = 4194304
      pEngineName = No Engine
      engineVersion = 4194304
      apiVersion = 4194304
     pNext:

t{0} f{0} vkCreateWin32SurfaceKHR(instance = 0x71e868, pCreateInfo = 0x20f870, p
Allocator = 0x0, *pSurface = 0x6d80a8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
    pNext = 0x0
    flags = 0x0
    hinstance = 0xc00000
    hwnd = 0x5097c

t{0} f{0} vkEnumeratePhysicalDevices(instance = 0x71e868, *pPhysicalDeviceCount
= 0x1, pPhysicalDevices = 0x0) = VK_SUCCESS
t{0} f{0} vkEnumeratePhysicalDevices(instance = 0x71e868, *pPhysicalDeviceCount
= 0x1, *pPhysicalDevices = 0x49e7640) = VK_SUCCESS
   pPhysicalDevices[0] = 0x49e7640
t{0} f{0} vkGetPhysicalDeviceFeatures(physicalDevice = 0x49e7640, pFeatures = 0x
47f4138)
   pFeatures:
    robustBufferAccess = TRUE
    fullDrawIndexUint32 = TRUE
    imageCubeArray = TRUE
    independentBlend = TRUE
    geometryShader = TRUE
    tessellationShader = TRUE
    sampleRateShading = TRUE
    dualSrcBlend = TRUE
    logicOp = TRUE
    multiDrawIndirect = TRUE
    drawIndirectFirstInstance = TRUE
    depthClamp = TRUE
    depthBiasClamp = TRUE
    fillModeNonSolid = TRUE
    depthBounds = TRUE
    wideLines = TRUE
    largePoints = TRUE
    alphaToOne = TRUE
    multiViewport = TRUE
    samplerAnisotropy = TRUE
    textureCompressionETC2 = FALSE
    textureCompressionASTC_LDR = FALSE
    textureCompressionBC = TRUE
    occlusionQueryPrecise = TRUE
    pipelineStatisticsQuery = TRUE
    vertexPipelineStoresAndAtomics = TRUE
    fragmentStoresAndAtomics = TRUE
    shaderTessellationAndGeometryPointSize = TRUE
    shaderImageGatherExtended = TRUE
    shaderStorageImageExtendedFormats = TRUE
    shaderStorageImageMultisample = TRUE
    shaderStorageImageReadWithoutFormat = FALSE
    shaderStorageImageWriteWithoutFormat = TRUE
    shaderUniformBufferArrayDynamicIndexing = TRUE
    shaderSampledImageArrayDynamicIndexing = TRUE
    shaderStorageBufferArrayDynamicIndexing = TRUE
    shaderStorageImageArrayDynamicIndexing = TRUE
    shaderClipDistance = TRUE
    shaderCullDistance = TRUE
    shaderFloat64 = TRUE
    shaderInt64 = TRUE
    shaderInt16 = FALSE
    shaderResourceResidency = FALSE
    shaderResourceMinLod = FALSE
    sparseBinding = TRUE
    sparseResidencyBuffer = FALSE
    sparseResidencyImage2D = FALSE
    sparseResidencyImage3D = FALSE
    sparseResidency2Samples = FALSE
    sparseResidency4Samples = FALSE
    sparseResidency8Samples = FALSE
    sparseResidency16Samples = FALSE
    sparseResidencyAliased = FALSE
    variableMultisampleRate = TRUE
    inheritedQueries = TRUE

t{0} f{0} vkGetPhysicalDeviceFeatures(physicalDevice = 0x49e7640, pFeatures = 0x
47f4450)
   pFeatures:
    robustBufferAccess = TRUE
    fullDrawIndexUint32 = TRUE
    imageCubeArray = TRUE
    independentBlend = TRUE
    geometryShader = TRUE
    tessellationShader = TRUE
    sampleRateShading = TRUE
    dualSrcBlend = TRUE
    logicOp = TRUE
    multiDrawIndirect = TRUE
    drawIndirectFirstInstance = TRUE
    depthClamp = TRUE
    depthBiasClamp = TRUE
    fillModeNonSolid = TRUE
    depthBounds = TRUE
    wideLines = TRUE
    largePoints = TRUE
    alphaToOne = TRUE
    multiViewport = TRUE
    samplerAnisotropy = TRUE
    textureCompressionETC2 = FALSE
    textureCompressionASTC_LDR = FALSE
    textureCompressionBC = TRUE
    occlusionQueryPrecise = TRUE
    pipelineStatisticsQuery = TRUE
    vertexPipelineStoresAndAtomics = TRUE
    fragmentStoresAndAtomics = TRUE
    shaderTessellationAndGeometryPointSize = TRUE
    shaderImageGatherExtended = TRUE
    shaderStorageImageExtendedFormats = TRUE
    shaderStorageImageMultisample = TRUE
    shaderStorageImageReadWithoutFormat = FALSE
    shaderStorageImageWriteWithoutFormat = TRUE
    shaderUniformBufferArrayDynamicIndexing = TRUE
    shaderSampledImageArrayDynamicIndexing = TRUE
    shaderStorageBufferArrayDynamicIndexing = TRUE
    shaderStorageImageArrayDynamicIndexing = TRUE
    shaderClipDistance = TRUE
    shaderCullDistance = TRUE
    shaderFloat64 = TRUE
    shaderInt64 = TRUE
    shaderInt16 = FALSE
    shaderResourceResidency = FALSE
    shaderResourceMinLod = FALSE
    sparseBinding = TRUE
    sparseResidencyBuffer = FALSE
    sparseResidencyImage2D = FALSE
    sparseResidencyImage3D = FALSE
    sparseResidency2Samples = FALSE
    sparseResidency4Samples = FALSE
    sparseResidency8Samples = FALSE
    sparseResidency16Samples = FALSE
    sparseResidencyAliased = FALSE
    variableMultisampleRate = TRUE
    inheritedQueries = TRUE

t{0} f{0} vkEnumeratePhysicalDevices(instance = 0x71e868, *pPhysicalDeviceCount
= 0x1, pPhysicalDevices = 0x0) = VK_SUCCESS
t{0} f{0} vkEnumeratePhysicalDevices(instance = 0x71e868, *pPhysicalDeviceCount
= 0x1, *pPhysicalDevices = 0x49e7640) = VK_SUCCESS
   pPhysicalDevices[0] = 0x49e7640
t{0} f{0} vkGetPhysicalDeviceFeatures(physicalDevice = 0x49e7640, pFeatures = 0x
47f4138)
   pFeatures:
    robustBufferAccess = TRUE
    fullDrawIndexUint32 = TRUE
    imageCubeArray = TRUE
    independentBlend = TRUE
    geometryShader = TRUE
    tessellationShader = TRUE
    sampleRateShading = TRUE
    dualSrcBlend = TRUE
    logicOp = TRUE
    multiDrawIndirect = TRUE
    drawIndirectFirstInstance = TRUE
    depthClamp = TRUE
    depthBiasClamp = TRUE
    fillModeNonSolid = TRUE
    depthBounds = TRUE
    wideLines = TRUE
    largePoints = TRUE
    alphaToOne = TRUE
    multiViewport = TRUE
    samplerAnisotropy = TRUE
    textureCompressionETC2 = FALSE
    textureCompressionASTC_LDR = FALSE
    textureCompressionBC = TRUE
    occlusionQueryPrecise = TRUE
    pipelineStatisticsQuery = TRUE
    vertexPipelineStoresAndAtomics = TRUE
    fragmentStoresAndAtomics = TRUE
    shaderTessellationAndGeometryPointSize = TRUE
    shaderImageGatherExtended = TRUE
    shaderStorageImageExtendedFormats = TRUE
    shaderStorageImageMultisample = TRUE
    shaderStorageImageReadWithoutFormat = FALSE
    shaderStorageImageWriteWithoutFormat = TRUE
    shaderUniformBufferArrayDynamicIndexing = TRUE
    shaderSampledImageArrayDynamicIndexing = TRUE
    shaderStorageBufferArrayDynamicIndexing = TRUE
    shaderStorageImageArrayDynamicIndexing = TRUE
    shaderClipDistance = TRUE
    shaderCullDistance = TRUE
    shaderFloat64 = TRUE
    shaderInt64 = TRUE
    shaderInt16 = FALSE
    shaderResourceResidency = FALSE
    shaderResourceMinLod = FALSE
    sparseBinding = TRUE
    sparseResidencyBuffer = FALSE
    sparseResidencyImage2D = FALSE
    sparseResidencyImage3D = FALSE
    sparseResidency2Samples = FALSE
    sparseResidency4Samples = FALSE
    sparseResidency8Samples = FALSE
    sparseResidency16Samples = FALSE
    sparseResidencyAliased = FALSE
    variableMultisampleRate = TRUE
    inheritedQueries = TRUE

t{0} f{0} vkGetPhysicalDeviceFeatures(physicalDevice = 0x49e7640, pFeatures = 0x
47f4450)
   pFeatures:
    robustBufferAccess = TRUE
    fullDrawIndexUint32 = TRUE
    imageCubeArray = TRUE
    independentBlend = TRUE
    geometryShader = TRUE
    tessellationShader = TRUE
    sampleRateShading = TRUE
    dualSrcBlend = TRUE
    logicOp = TRUE
    multiDrawIndirect = TRUE
    drawIndirectFirstInstance = TRUE
    depthClamp = TRUE
    depthBiasClamp = TRUE
    fillModeNonSolid = TRUE
    depthBounds = TRUE
    wideLines = TRUE
    largePoints = TRUE
    alphaToOne = TRUE
    multiViewport = TRUE
    samplerAnisotropy = TRUE
    textureCompressionETC2 = FALSE
    textureCompressionASTC_LDR = FALSE
    textureCompressionBC = TRUE
    occlusionQueryPrecise = TRUE
    pipelineStatisticsQuery = TRUE
    vertexPipelineStoresAndAtomics = TRUE
    fragmentStoresAndAtomics = TRUE
    shaderTessellationAndGeometryPointSize = TRUE
    shaderImageGatherExtended = TRUE
    shaderStorageImageExtendedFormats = TRUE
    shaderStorageImageMultisample = TRUE
    shaderStorageImageReadWithoutFormat = FALSE
    shaderStorageImageWriteWithoutFormat = TRUE
    shaderUniformBufferArrayDynamicIndexing = TRUE
    shaderSampledImageArrayDynamicIndexing = TRUE
    shaderStorageBufferArrayDynamicIndexing = TRUE
    shaderStorageImageArrayDynamicIndexing = TRUE
    shaderClipDistance = TRUE
    shaderCullDistance = TRUE
    shaderFloat64 = TRUE
    shaderInt64 = TRUE
    shaderInt16 = FALSE
    shaderResourceResidency = FALSE
    shaderResourceMinLod = FALSE
    sparseBinding = TRUE
    sparseResidencyBuffer = FALSE
    sparseResidencyImage2D = FALSE
    sparseResidencyImage3D = FALSE
    sparseResidency2Samples = FALSE
    sparseResidency4Samples = FALSE
    sparseResidency8Samples = FALSE
    sparseResidency16Samples = FALSE
    sparseResidencyAliased = FALSE
    variableMultisampleRate = TRUE
    inheritedQueries = TRUE

t{0} f{0} vkGetPhysicalDeviceProperties(physicalDevice = 0x49e7640, pProperties
= 0x20f470)
   pProperties:
    apiVersion = 4194346
    driverVersion = 1603092480
    vendorID = 4318
    deviceID = 4544
    deviceType = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU
    deviceName = GeForce GTX 660
    pipelineCacheUUID = 0x20f584
    limits = 0x20f598
    sparseProperties = 0x20f788
     sparseProperties:
      residencyStandard2DBlockShape = TRUE
      residencyStandard2DMultisampleBlockShape = TRUE
      residencyStandard3DBlockShape = TRUE
      residencyAlignedMipSize = TRUE
      residencyNonResidentStrict = FALSE
     limits:
      maxImageDimension1D = 16384
      maxImageDimension2D = 16384
      maxImageDimension3D = 2048
      maxImageDimensionCube = 16384
      maxImageArrayLayers = 2048
      maxTexelBufferElements = 0x8000000
      maxUniformBufferRange = 0x10000
      maxStorageBufferRange = 0x7fffffff
      maxPushConstantsSize = 0x100
      maxMemoryAllocationCount = 0x1000
      maxSamplerAllocationCount = 0xfa0
      bufferImageGranularity = 0x10000
      sparseAddressSpaceSize = 0xffffffffffffffff
      maxBoundDescriptorSets = 8
      maxPerStageDescriptorSamplers = 4000
      maxPerStageDescriptorUniformBuffers = 0xc
      maxPerStageDescriptorStorageBuffers = 0x10
      maxPerStageDescriptorSampledImages = 8192
      maxPerStageDescriptorStorageImages = 8192
      maxPerStageDescriptorInputAttachments = 8
      maxPerStageResources = 24612
      maxDescriptorSetSamplers = 4000
      maxDescriptorSetUniformBuffers = 0x48
      maxDescriptorSetUniformBuffersDynamic = 0x48
      maxDescriptorSetStorageBuffers = 0x60
      maxDescriptorSetStorageBuffersDynamic = 0x60
      maxDescriptorSetSampledImages = 49152
      maxDescriptorSetStorageImages = 49152
      maxDescriptorSetInputAttachments = 8
      maxVertexInputAttributes = 32
      maxVertexInputBindings = 32
      maxVertexInputAttributeOffset = 0x7ff
      maxVertexInputBindingStride = 2048
      maxVertexOutputComponents = 128
      maxTessellationGenerationLevel = 64
      maxTessellationPatchSize = 0x20
      maxTessellationControlPerVertexInputComponents = 128
      maxTessellationControlPerVertexOutputComponents = 128
      maxTessellationControlPerPatchOutputComponents = 120
      maxTessellationControlTotalOutputComponents = 4216
      maxTessellationEvaluationInputComponents = 128
      maxTessellationEvaluationOutputComponents = 128
      maxGeometryShaderInvocations = 32
      maxGeometryInputComponents = 128
      maxGeometryOutputComponents = 128
      maxGeometryOutputVertices = 1024
      maxGeometryTotalOutputComponents = 1024
      maxFragmentInputComponents = 128
      maxFragmentOutputAttachments = 8
      maxFragmentDualSrcAttachments = 1
      maxFragmentCombinedOutputResources = 16
      maxComputeSharedMemorySize = 0xc000
      maxComputeWorkGroupCount = 0x20f674
      maxComputeWorkGroupInvocations = 1536
      maxComputeWorkGroupSize = 0x20f684
      subPixelPrecisionBits = 0x8
      subTexelPrecisionBits = 0x8
      mipmapPrecisionBits = 0x8
      maxDrawIndexedIndexValue = 0xffffffff
      maxDrawIndirectCount = 0xffffffff
      maxSamplerLodBias = 15
      maxSamplerAnisotropy = 16
      maxViewports = 16
      maxViewportDimensions = 0x20f6b0
      viewportBoundsRange = 0x20f6b8
      viewportSubPixelBits = 0x8
      minMemoryMapAlignment = 0x40
      minTexelBufferOffsetAlignment = 0x100
      minUniformBufferOffsetAlignment = 0x100
      minStorageBufferOffsetAlignment = 0x20
      minTexelOffset = 0xfffffff8
      maxTexelOffset = 0x7
      minTexelGatherOffset = 0xffffffe0
      maxTexelGatherOffset = 0x1f
      minInterpolationOffset = -0.5
      maxInterpolationOffset = 0.4375
      subPixelInterpolationOffsetBits = 0x4
      maxFramebufferWidth = 0x4000
      maxFramebufferHeight = 0x4000
      maxFramebufferLayers = 0x800
      framebufferColorSampleCounts = 0xf
      framebufferDepthSampleCounts = 0xf
      framebufferStencilSampleCounts = 0xf
      framebufferNoAttachmentsSampleCounts = 0xf
      maxColorAttachments = 8
      sampledImageColorSampleCounts = 0xf
      sampledImageIntegerSampleCounts = 0xf
      sampledImageDepthSampleCounts = 0xf
      sampledImageStencilSampleCounts = 0xf
      storageImageSampleCounts = 0xf
      maxSampleMaskWords = 0x1
      timestampComputeAndGraphics = TRUE
      timestampPeriod = 1
      maxClipDistances = 8
      maxCullDistances = 8
      maxCombinedClipAndCullDistances = 8
      discreteQueuePriorities = 2
      pointSizeRange = 0x20f74c
      lineWidthRange = 0x20f754
      pointSizeGranularity = 0.125
      lineWidthGranularity = 0.125
      strictLines = TRUE
      standardSampleLocations = TRUE
      optimalBufferCopyOffsetAlignment = 0x1
      optimalBufferCopyRowPitchAlignment = 0x1
      nonCoherentAtomSize = 0x40
       lineWidthRange[0] = 0.5
       lineWidthRange[1] = 10
       pointSizeRange[0] = 1
       pointSizeRange[1] = 189.875
       viewportBoundsRange[0] = -32768
       viewportBoundsRange[1] = 32768
       maxViewportDimensions[0] = 16384
       maxViewportDimensions[1] = 16384
       maxComputeWorkGroupSize[0] = 1536
       maxComputeWorkGroupSize[1] = 1024
       maxComputeWorkGroupSize[2] = 64
       maxComputeWorkGroupCount[0] = 2147483647
       maxComputeWorkGroupCount[1] = 65535
       maxComputeWorkGroupCount[2] = 65535
     pipelineCacheUUID[0] = 0x1f
     pipelineCacheUUID[1] = 0x43
     pipelineCacheUUID[2] = 0x3f
     pipelineCacheUUID[3] = 0x97
     pipelineCacheUUID[4] = 0x9
     pipelineCacheUUID[5] = 0xdc
     pipelineCacheUUID[6] = 0x62
     pipelineCacheUUID[7] = 0x6a
     pipelineCacheUUID[8] = 0x95
     pipelineCacheUUID[9] = 0x6c
     pipelineCacheUUID[10] = 0x75
     pipelineCacheUUID[11] = 0x7e
     pipelineCacheUUID[12] = 0xd2
     pipelineCacheUUID[13] = 0x1d
     pipelineCacheUUID[14] = 0x7f
     pipelineCacheUUID[15] = 0xa3

t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x6cc160)
   pQueueFamilyProperties:
    queueFlags = 0xf
    queueCount = 0x10
    timestampValidBits = 0x40
    minImageTransferGranularity = 0x6cc16c
     minImageTransferGranularity:
      width = 1
      height = 1
      depth = 1

t{0} f{0} vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice = 0x49e7640, queue
FamilyIndex = 0x0, surface = 0x6d80a8, pSupported = 0020F524) = VK_SUCCESS
t{0} f{0} vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice = 0x49e7640,
surface = 0x6d80a8, pSurfaceCapabilities = 0x20f550) = VK_SUCCESS
   pSurfaceCapabilities:
    minImageCount = 0x2
    maxImageCount = 0x8
    currentExtent = 0x20f558
    minImageExtent = 0x20f560
    maxImageExtent = 0x20f568
    maxImageArrayLayers = 2048
    supportedTransforms = 0x1
    currentTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR
    supportedCompositeAlpha = 0x1
    supportedUsageFlags = 0x9f
     maxImageExtent:
      width = 16384
      height = 16384
     minImageExtent:
      width = 1
      height = 1
     currentExtent:
      width = 800
      height = 600

t{0} f{0} vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice = 0x49e7640, surfa
ce = 0x6d80a8, *pSurfaceFormatCount = 0x2, pSurfaceFormats = 0x0) = VK_SUCCESS
t{0} f{0} vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice = 0x49e7640, surfa
ce = 0x6d80a8, *pSurfaceFormatCount = 0x2, pSurfaceFormats = 0x6c4e00) = VK_SUCC
ESS
   pSurfaceFormats[0]:
    format = VK_FORMAT_B8G8R8A8_UNORM
    colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR

   pSurfaceFormats[1]:
    format = VK_FORMAT_B8G8R8A8_SRGB
    colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR

t{0} f{0} vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice = 0x49e7640,
surface = 0x6d80a8, *pPresentModeCount = 0x3, pPresentModes = 0x0) = VK_SUCCESS
t{0} f{0} vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice = 0x49e7640,
surface = 0x6d80a8, *pPresentModeCount = 0x3, pPresentModes = 0x49d2048) = VK_SU
CCESS
   pPresentModes[0]:
    2
   pPresentModes[1]:
    3
   pPresentModes[2]:
    1
t{0} f{0} vkGetPhysicalDeviceFeatures(physicalDevice = 0x49e7640, pFeatures = 0x
20f6a8)
   pFeatures:
    robustBufferAccess = TRUE
    fullDrawIndexUint32 = TRUE
    imageCubeArray = TRUE
    independentBlend = TRUE
    geometryShader = TRUE
    tessellationShader = TRUE
    sampleRateShading = TRUE
    dualSrcBlend = TRUE
    logicOp = TRUE
    multiDrawIndirect = TRUE
    drawIndirectFirstInstance = TRUE
    depthClamp = TRUE
    depthBiasClamp = TRUE
    fillModeNonSolid = TRUE
    depthBounds = TRUE
    wideLines = TRUE
    largePoints = TRUE
    alphaToOne = TRUE
    multiViewport = TRUE
    samplerAnisotropy = TRUE
    textureCompressionETC2 = FALSE
    textureCompressionASTC_LDR = FALSE
    textureCompressionBC = TRUE
    occlusionQueryPrecise = TRUE
    pipelineStatisticsQuery = TRUE
    vertexPipelineStoresAndAtomics = TRUE
    fragmentStoresAndAtomics = TRUE
    shaderTessellationAndGeometryPointSize = TRUE
    shaderImageGatherExtended = TRUE
    shaderStorageImageExtendedFormats = TRUE
    shaderStorageImageMultisample = TRUE
    shaderStorageImageReadWithoutFormat = FALSE
    shaderStorageImageWriteWithoutFormat = TRUE
    shaderUniformBufferArrayDynamicIndexing = TRUE
    shaderSampledImageArrayDynamicIndexing = TRUE
    shaderStorageBufferArrayDynamicIndexing = TRUE
    shaderStorageImageArrayDynamicIndexing = TRUE
    shaderClipDistance = TRUE
    shaderCullDistance = TRUE
    shaderFloat64 = TRUE
    shaderInt64 = TRUE
    shaderInt16 = FALSE
    shaderResourceResidency = FALSE
    shaderResourceMinLod = FALSE
    sparseBinding = TRUE
    sparseResidencyBuffer = FALSE
    sparseResidencyImage2D = FALSE
    sparseResidencyImage3D = FALSE
    sparseResidency2Samples = FALSE
    sparseResidency4Samples = FALSE
    sparseResidency8Samples = FALSE
    sparseResidency16Samples = FALSE
    sparseResidencyAliased = FALSE
    variableMultisampleRate = TRUE
    inheritedQueries = TRUE

t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x6cc160)
   pQueueFamilyProperties:
    queueFlags = 0xf
    queueCount = 0x10
    timestampValidBits = 0x40
    minImageTransferGranularity = 0x6cc16c
     minImageTransferGranularity:
      width = 1
      height = 1
      depth = 1

t{0} f{0} vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice = 0x49e7640, queue
FamilyIndex = 0x0, surface = 0x6d80a8, pSupported = 0020F550) = VK_SUCCESS
t{0} f{0} vkCreateDevice(physicalDevice = 0x49e7640, pCreateInfo = 0x20f53c, pAl
locator = 0x0, *pDevice = 0x49d66f8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
    pNext = 0x20f564
    flags = 0x0
    queueCreateInfoCount = 0x1
    pQueueCreateInfos = 0x49ca9a8
    enabledLayerCount = 0x2
    ppEnabledLayerNames = 0x6c55f8
    enabledExtensionCount = 0x1
    ppEnabledExtensionNames = 0x6c3968
    pEnabledFeatures = 0x20f7f8
     pEnabledFeatures:
      robustBufferAccess = FALSE
      fullDrawIndexUint32 = FALSE
      imageCubeArray = FALSE
      independentBlend = FALSE
      geometryShader = FALSE
      tessellationShader = FALSE
      sampleRateShading = FALSE
      dualSrcBlend = FALSE
      logicOp = FALSE
      multiDrawIndirect = FALSE
      drawIndirectFirstInstance = FALSE
      depthClamp = FALSE
      depthBiasClamp = FALSE
      fillModeNonSolid = FALSE
      depthBounds = FALSE
      wideLines = FALSE
      largePoints = FALSE
      alphaToOne = FALSE
      multiViewport = FALSE
      samplerAnisotropy = FALSE
      textureCompressionETC2 = FALSE
      textureCompressionASTC_LDR = FALSE
      textureCompressionBC = FALSE
      occlusionQueryPrecise = FALSE
      pipelineStatisticsQuery = FALSE
      vertexPipelineStoresAndAtomics = FALSE
      fragmentStoresAndAtomics = FALSE
      shaderTessellationAndGeometryPointSize = FALSE
      shaderImageGatherExtended = FALSE
      shaderStorageImageExtendedFormats = FALSE
      shaderStorageImageMultisample = FALSE
      shaderStorageImageReadWithoutFormat = FALSE
      shaderStorageImageWriteWithoutFormat = FALSE
      shaderUniformBufferArrayDynamicIndexing = FALSE
      shaderSampledImageArrayDynamicIndexing = FALSE
      shaderStorageBufferArrayDynamicIndexing = FALSE
      shaderStorageImageArrayDynamicIndexing = FALSE
      shaderClipDistance = FALSE
      shaderCullDistance = FALSE
      shaderFloat64 = FALSE
      shaderInt64 = FALSE
      shaderInt16 = FALSE
      shaderResourceResidency = FALSE
      shaderResourceMinLod = FALSE
      sparseBinding = FALSE
      sparseResidencyBuffer = FALSE
      sparseResidencyImage2D = FALSE
      sparseResidencyImage3D = FALSE
      sparseResidency2Samples = FALSE
      sparseResidency4Samples = FALSE
      sparseResidency8Samples = FALSE
      sparseResidency16Samples = FALSE
      sparseResidencyAliased = FALSE
      variableMultisampleRate = FALSE
      inheritedQueries = FALSE
     pQueueCreateInfos[0]:
      sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      queueFamilyIndex = 0x0
      queueCount = 0x1
      pQueuePriorities = 0x20f93c
       pQueuePriorities[0] = 0x1
     pNext:

t{0} f{0} vkGetPhysicalDeviceProperties(physicalDevice = 0x49e7640, pProperties
= 0x48055a0)
   pProperties:
    apiVersion = 4194346
    driverVersion = 1603092480
    vendorID = 4318
    deviceID = 4544
    deviceType = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU
    deviceName = GeForce GTX 660
    pipelineCacheUUID = 0x48056b4
    limits = 0x48056c8
    sparseProperties = 0x48058b8
     sparseProperties:
      residencyStandard2DBlockShape = TRUE
      residencyStandard2DMultisampleBlockShape = TRUE
      residencyStandard3DBlockShape = TRUE
      residencyAlignedMipSize = TRUE
      residencyNonResidentStrict = FALSE
     limits:
      maxImageDimension1D = 16384
      maxImageDimension2D = 16384
      maxImageDimension3D = 2048
      maxImageDimensionCube = 16384
      maxImageArrayLayers = 2048
      maxTexelBufferElements = 0x8000000
      maxUniformBufferRange = 0x10000
      maxStorageBufferRange = 0x7fffffff
      maxPushConstantsSize = 0x100
      maxMemoryAllocationCount = 0x1000
      maxSamplerAllocationCount = 0xfa0
      bufferImageGranularity = 0x10000
      sparseAddressSpaceSize = 0xffffffffffffffff
      maxBoundDescriptorSets = 8
      maxPerStageDescriptorSamplers = 4000
      maxPerStageDescriptorUniformBuffers = 0xc
      maxPerStageDescriptorStorageBuffers = 0x10
      maxPerStageDescriptorSampledImages = 8192
      maxPerStageDescriptorStorageImages = 8192
      maxPerStageDescriptorInputAttachments = 8
      maxPerStageResources = 24612
      maxDescriptorSetSamplers = 4000
      maxDescriptorSetUniformBuffers = 0x48
      maxDescriptorSetUniformBuffersDynamic = 0x48
      maxDescriptorSetStorageBuffers = 0x60
      maxDescriptorSetStorageBuffersDynamic = 0x60
      maxDescriptorSetSampledImages = 49152
      maxDescriptorSetStorageImages = 49152
      maxDescriptorSetInputAttachments = 8
      maxVertexInputAttributes = 32
      maxVertexInputBindings = 32
      maxVertexInputAttributeOffset = 0x7ff
      maxVertexInputBindingStride = 2048
      maxVertexOutputComponents = 128
      maxTessellationGenerationLevel = 64
      maxTessellationPatchSize = 0x20
      maxTessellationControlPerVertexInputComponents = 128
      maxTessellationControlPerVertexOutputComponents = 128
      maxTessellationControlPerPatchOutputComponents = 120
      maxTessellationControlTotalOutputComponents = 4216
      maxTessellationEvaluationInputComponents = 128
      maxTessellationEvaluationOutputComponents = 128
      maxGeometryShaderInvocations = 32
      maxGeometryInputComponents = 128
      maxGeometryOutputComponents = 128
      maxGeometryOutputVertices = 1024
      maxGeometryTotalOutputComponents = 1024
      maxFragmentInputComponents = 128
      maxFragmentOutputAttachments = 8
      maxFragmentDualSrcAttachments = 1
      maxFragmentCombinedOutputResources = 16
      maxComputeSharedMemorySize = 0xc000
      maxComputeWorkGroupCount = 0x48057a4
      maxComputeWorkGroupInvocations = 1536
      maxComputeWorkGroupSize = 0x48057b4
      subPixelPrecisionBits = 0x8
      subTexelPrecisionBits = 0x8
      mipmapPrecisionBits = 0x8
      maxDrawIndexedIndexValue = 0xffffffff
      maxDrawIndirectCount = 0xffffffff
      maxSamplerLodBias = 15
      maxSamplerAnisotropy = 16
      maxViewports = 16
      maxViewportDimensions = 0x48057e0
      viewportBoundsRange = 0x48057e8
      viewportSubPixelBits = 0x8
      minMemoryMapAlignment = 0x40
      minTexelBufferOffsetAlignment = 0x100
      minUniformBufferOffsetAlignment = 0x100
      minStorageBufferOffsetAlignment = 0x20
      minTexelOffset = 0xfffffff8
      maxTexelOffset = 0x7
      minTexelGatherOffset = 0xffffffe0
      maxTexelGatherOffset = 0x1f
      minInterpolationOffset = -0.5
      maxInterpolationOffset = 0.4375
      subPixelInterpolationOffsetBits = 0x4
      maxFramebufferWidth = 0x4000
      maxFramebufferHeight = 0x4000
      maxFramebufferLayers = 0x800
      framebufferColorSampleCounts = 0xf
      framebufferDepthSampleCounts = 0xf
      framebufferStencilSampleCounts = 0xf
      framebufferNoAttachmentsSampleCounts = 0xf
      maxColorAttachments = 8
      sampledImageColorSampleCounts = 0xf
      sampledImageIntegerSampleCounts = 0xf
      sampledImageDepthSampleCounts = 0xf
      sampledImageStencilSampleCounts = 0xf
      storageImageSampleCounts = 0xf
      maxSampleMaskWords = 0x1
      timestampComputeAndGraphics = TRUE
      timestampPeriod = 1
      maxClipDistances = 8
      maxCullDistances = 8
      maxCombinedClipAndCullDistances = 8
      discreteQueuePriorities = 2
      pointSizeRange = 0x480587c
      lineWidthRange = 0x4805884
      pointSizeGranularity = 0.125
      lineWidthGranularity = 0.125
      strictLines = TRUE
      standardSampleLocations = TRUE
      optimalBufferCopyOffsetAlignment = 0x1
      optimalBufferCopyRowPitchAlignment = 0x1
      nonCoherentAtomSize = 0x40
       lineWidthRange[0] = 0.5
       lineWidthRange[1] = 10
       pointSizeRange[0] = 1
       pointSizeRange[1] = 189.875
       viewportBoundsRange[0] = -32768
       viewportBoundsRange[1] = 32768
       maxViewportDimensions[0] = 16384
       maxViewportDimensions[1] = 16384
       maxComputeWorkGroupSize[0] = 1536
       maxComputeWorkGroupSize[1] = 1024
       maxComputeWorkGroupSize[2] = 64
       maxComputeWorkGroupCount[0] = 2147483647
       maxComputeWorkGroupCount[1] = 65535
       maxComputeWorkGroupCount[2] = 65535
     pipelineCacheUUID[0] = 0x1f
     pipelineCacheUUID[1] = 0x43
     pipelineCacheUUID[2] = 0x3f
     pipelineCacheUUID[3] = 0x97
     pipelineCacheUUID[4] = 0x9
     pipelineCacheUUID[5] = 0xdc
     pipelineCacheUUID[6] = 0x62
     pipelineCacheUUID[7] = 0x6a
     pipelineCacheUUID[8] = 0x95
     pipelineCacheUUID[9] = 0x6c
     pipelineCacheUUID[10] = 0x75
     pipelineCacheUUID[11] = 0x7e
     pipelineCacheUUID[12] = 0xd2
     pipelineCacheUUID[13] = 0x1d
     pipelineCacheUUID[14] = 0x7f
     pipelineCacheUUID[15] = 0xa3

t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x49d25a0)
   pQueueFamilyProperties:
    queueFlags = 0xf
    queueCount = 0x10
    timestampValidBits = 0x40
    minImageTransferGranularity = 0x49d25ac
     minImageTransferGranularity:
      width = 1
      height = 1
      depth = 1

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x48059b8)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x48059bc
    memoryHeapCount = 0x2
    memoryHeaps = 0x4805ac0
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0x0
      flags = 0x0
     memoryHeaps[3]:
      size = 0x0
      flags = 0x0
     memoryHeaps[4]:
      size = 0x0
      flags = 0x0
     memoryHeaps[5]:
      size = 0x0
      flags = 0x0
     memoryHeaps[6]:
      size = 0x0
      flags = 0x0
     memoryHeaps[7]:
      size = 0x0
      flags = 0x0
     memoryHeaps[8]:
      size = 0x0
      flags = 0x0
     memoryHeaps[9]:
      size = 0x0
      flags = 0x0
     memoryHeaps[10]:
      size = 0x0
      flags = 0x0
     memoryHeaps[11]:
      size = 0x0
      flags = 0x0
     memoryHeaps[12]:
      size = 0x0
      flags = 0x0
     memoryHeaps[13]:
      size = 0x0
      flags = 0x0
     memoryHeaps[14]:
      size = 0x0
      flags = 0x0
     memoryHeaps[15]:
      size = 0x0
      flags = 0x0
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[12]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[13]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[14]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[15]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[16]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[17]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[18]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[19]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[20]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[21]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[22]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[23]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[24]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[25]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[26]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[27]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[28]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[29]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[30]:
      propertyFlags = 0x0
      heapIndex = 0x0
     memoryTypes[31]:
      propertyFlags = 0x0
      heapIndex = 0x0

t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x49d1b90)
   pQueueFamilyProperties:
    queueFlags = 0xf
    queueCount = 0x10
    timestampValidBits = 0x40
    minImageTransferGranularity = 0x49d1b9c
     minImageTransferGranularity:
      width = 1
      height = 1
      depth = 1

t{0} f{0} vkGetPhysicalDeviceProperties(physicalDevice = 0x49e7640, pProperties
= 0x20f0d0)
   pProperties:
    apiVersion = 4194346
    driverVersion = 1603092480
    vendorID = 4318
    deviceID = 4544
    deviceType = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU
    deviceName = GeForce GTX 660
    pipelineCacheUUID = 0x20f1e4
    limits = 0x20f1f8
    sparseProperties = 0x20f3e8
     sparseProperties:
      residencyStandard2DBlockShape = TRUE
      residencyStandard2DMultisampleBlockShape = TRUE
      residencyStandard3DBlockShape = TRUE
      residencyAlignedMipSize = TRUE
      residencyNonResidentStrict = FALSE
     limits:
      maxImageDimension1D = 16384
      maxImageDimension2D = 16384
      maxImageDimension3D = 2048
      maxImageDimensionCube = 16384
      maxImageArrayLayers = 2048
      maxTexelBufferElements = 0x8000000
      maxUniformBufferRange = 0x10000
      maxStorageBufferRange = 0x7fffffff
      maxPushConstantsSize = 0x100
      maxMemoryAllocationCount = 0x1000
      maxSamplerAllocationCount = 0xfa0
      bufferImageGranularity = 0x10000
      sparseAddressSpaceSize = 0xffffffffffffffff
      maxBoundDescriptorSets = 8
      maxPerStageDescriptorSamplers = 4000
      maxPerStageDescriptorUniformBuffers = 0xc
      maxPerStageDescriptorStorageBuffers = 0x10
      maxPerStageDescriptorSampledImages = 8192
      maxPerStageDescriptorStorageImages = 8192
      maxPerStageDescriptorInputAttachments = 8
      maxPerStageResources = 24612
      maxDescriptorSetSamplers = 4000
      maxDescriptorSetUniformBuffers = 0x48
      maxDescriptorSetUniformBuffersDynamic = 0x48
      maxDescriptorSetStorageBuffers = 0x60
      maxDescriptorSetStorageBuffersDynamic = 0x60
      maxDescriptorSetSampledImages = 49152
      maxDescriptorSetStorageImages = 49152
      maxDescriptorSetInputAttachments = 8
      maxVertexInputAttributes = 32
      maxVertexInputBindings = 32
      maxVertexInputAttributeOffset = 0x7ff
      maxVertexInputBindingStride = 2048
      maxVertexOutputComponents = 128
      maxTessellationGenerationLevel = 64
      maxTessellationPatchSize = 0x20
      maxTessellationControlPerVertexInputComponents = 128
      maxTessellationControlPerVertexOutputComponents = 128
      maxTessellationControlPerPatchOutputComponents = 120
      maxTessellationControlTotalOutputComponents = 4216
      maxTessellationEvaluationInputComponents = 128
      maxTessellationEvaluationOutputComponents = 128
      maxGeometryShaderInvocations = 32
      maxGeometryInputComponents = 128
      maxGeometryOutputComponents = 128
      maxGeometryOutputVertices = 1024
      maxGeometryTotalOutputComponents = 1024
      maxFragmentInputComponents = 128
      maxFragmentOutputAttachments = 8
      maxFragmentDualSrcAttachments = 1
      maxFragmentCombinedOutputResources = 16
      maxComputeSharedMemorySize = 0xc000
      maxComputeWorkGroupCount = 0x20f2d4
      maxComputeWorkGroupInvocations = 1536
      maxComputeWorkGroupSize = 0x20f2e4
      subPixelPrecisionBits = 0x8
      subTexelPrecisionBits = 0x8
      mipmapPrecisionBits = 0x8
      maxDrawIndexedIndexValue = 0xffffffff
      maxDrawIndirectCount = 0xffffffff
      maxSamplerLodBias = 15
      maxSamplerAnisotropy = 16
      maxViewports = 16
      maxViewportDimensions = 0x20f310
      viewportBoundsRange = 0x20f318
      viewportSubPixelBits = 0x8
      minMemoryMapAlignment = 0x40
      minTexelBufferOffsetAlignment = 0x100
      minUniformBufferOffsetAlignment = 0x100
      minStorageBufferOffsetAlignment = 0x20
      minTexelOffset = 0xfffffff8
      maxTexelOffset = 0x7
      minTexelGatherOffset = 0xffffffe0
      maxTexelGatherOffset = 0x1f
      minInterpolationOffset = -0.5
      maxInterpolationOffset = 0.4375
      subPixelInterpolationOffsetBits = 0x4
      maxFramebufferWidth = 0x4000
      maxFramebufferHeight = 0x4000
      maxFramebufferLayers = 0x800
      framebufferColorSampleCounts = 0xf
      framebufferDepthSampleCounts = 0xf
      framebufferStencilSampleCounts = 0xf
      framebufferNoAttachmentsSampleCounts = 0xf
      maxColorAttachments = 8
      sampledImageColorSampleCounts = 0xf
      sampledImageIntegerSampleCounts = 0xf
      sampledImageDepthSampleCounts = 0xf
      sampledImageStencilSampleCounts = 0xf
      storageImageSampleCounts = 0xf
      maxSampleMaskWords = 0x1
      timestampComputeAndGraphics = TRUE
      timestampPeriod = 1
      maxClipDistances = 8
      maxCullDistances = 8
      maxCombinedClipAndCullDistances = 8
      discreteQueuePriorities = 2
      pointSizeRange = 0x20f3ac
      lineWidthRange = 0x20f3b4
      pointSizeGranularity = 0.125
      lineWidthGranularity = 0.125
      strictLines = TRUE
      standardSampleLocations = TRUE
      optimalBufferCopyOffsetAlignment = 0x1
      optimalBufferCopyRowPitchAlignment = 0x1
      nonCoherentAtomSize = 0x40
       lineWidthRange[0] = 0.5
       lineWidthRange[1] = 10
       pointSizeRange[0] = 1
       pointSizeRange[1] = 189.875
       viewportBoundsRange[0] = -32768
       viewportBoundsRange[1] = 32768
       maxViewportDimensions[0] = 16384
       maxViewportDimensions[1] = 16384
       maxComputeWorkGroupSize[0] = 1536
       maxComputeWorkGroupSize[1] = 1024
       maxComputeWorkGroupSize[2] = 64
       maxComputeWorkGroupCount[0] = 2147483647
       maxComputeWorkGroupCount[1] = 65535
       maxComputeWorkGroupCount[2] = 65535
     pipelineCacheUUID[0] = 0x1f
     pipelineCacheUUID[1] = 0x43
     pipelineCacheUUID[2] = 0x3f
     pipelineCacheUUID[3] = 0x97
     pipelineCacheUUID[4] = 0x9
     pipelineCacheUUID[5] = 0xdc
     pipelineCacheUUID[6] = 0x62
     pipelineCacheUUID[7] = 0x6a
     pipelineCacheUUID[8] = 0x95
     pipelineCacheUUID[9] = 0x6c
     pipelineCacheUUID[10] = 0x75
     pipelineCacheUUID[11] = 0x7e
     pipelineCacheUUID[12] = 0xd2
     pipelineCacheUUID[13] = 0x1d
     pipelineCacheUUID[14] = 0x7f
     pipelineCacheUUID[15] = 0xa3

t{0} f{0} vkGetDeviceQueue(device = 0x49d66f8, queueFamilyIndex = 0x0, queueInde
x = 0x0, *pQueue = 0x6cc0e0)
t{0} f{0} vkGetDeviceQueue(device = 0x49d66f8, queueFamilyIndex = 0x0, queueInde
x = 0x0, *pQueue = 0x6cc0e0)
t{0} f{0} vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice = 0x49e7640,
surface = 0x6d80a8, pSurfaceCapabilities = 0x20f6f0) = VK_SUCCESS
   pSurfaceCapabilities:
    minImageCount = 0x2
    maxImageCount = 0x8
    currentExtent = 0x20f6f8
    minImageExtent = 0x20f700
    maxImageExtent = 0x20f708
    maxImageArrayLayers = 2048
    supportedTransforms = 0x1
    currentTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR
    supportedCompositeAlpha = 0x1
    supportedUsageFlags = 0x9f
     maxImageExtent:
      width = 16384
      height = 16384
     minImageExtent:
      width = 1
      height = 1
     currentExtent:
      width = 800
      height = 600

t{0} f{0} vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice = 0x49e7640, surfa
ce = 0x6d80a8, *pSurfaceFormatCount = 0x2, pSurfaceFormats = 0x0) = VK_SUCCESS
t{0} f{0} vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice = 0x49e7640, surfa
ce = 0x6d80a8, *pSurfaceFormatCount = 0x2, pSurfaceFormats = 0x6c4e00) = VK_SUCC
ESS
   pSurfaceFormats[0]:
    format = VK_FORMAT_B8G8R8A8_UNORM
    colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR

   pSurfaceFormats[1]:
    format = VK_FORMAT_B8G8R8A8_SRGB
    colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR

t{0} f{0} vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice = 0x49e7640,
surface = 0x6d80a8, *pPresentModeCount = 0x3, pPresentModes = 0x0) = VK_SUCCESS
t{0} f{0} vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice = 0x49e7640,
surface = 0x6d80a8, *pPresentModeCount = 0x3, pPresentModes = 0x49d12f0) = VK_SU
CCESS
   pPresentModes[0]:
    2
   pPresentModes[1]:
    3
   pPresentModes[2]:
    1
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x6cbfe0)
   pQueueFamilyProperties:
    queueFlags = 0xf
    queueCount = 0x10
    timestampValidBits = 0x40
    minImageTransferGranularity = 0x6cbfec
     minImageTransferGranularity:
      width = 1
      height = 1
      depth = 1

t{0} f{0} vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice = 0x49e7640, queue
FamilyIndex = 0x0, surface = 0x6d80a8, pSupported = 0020F6C4) = VK_SUCCESS
t{0} f{0} vkCreateSwapchainKHR(device = 0x49d66f8, pCreateInfo = 0x6cbfc0, pAllo
cator = 0x0, pSwapchain = 0x20fca8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
    pNext = 0x0
    flags = 0x0
    surface = 0x6d80a8
    minImageCount = 0x3
    imageFormat = VK_FORMAT_B8G8R8A8_UNORM
    imageColorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
    imageExtent = 0x6cbfe4
    imageArrayLayers = 1
    imageUsage = 0x10
    imageSharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0
    preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR
    compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR
    presentMode = VK_PRESENT_MODE_MAILBOX_KHR
    clipped = TRUE
    oldSwapchain = 0x0
     imageExtent:
      width = 800
      height = 600

t{0} f{0} vkGetSwapchainImagesKHR(device = 0x49d66f8, swapchain = 0x4801bb0, *pS
wapchainImageCount = 0x3, pSwapchainImages = 0x0) = VK_SUCCESS
t{0} f{0} vkGetSwapchainImagesKHR(device = 0x49d66f8, swapchain = 0x4801bb0, *pS
wapchainImageCount = 0x3, pSwapchainImages = 0x454f1d8) = VK_SUCCESS
   pSwapchainImages[0] = 0x4832688
   pSwapchainImages[1] = 0x48327a0
   pSwapchainImages[2] = 0x48328b8
t{0} f{0} vkCreateImageView(device = 0x49d66f8, pCreateInfo = 0x47f14b8, pAlloca
tor = 0x0, *pView = 0x6dce70) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    image = 0x4832688
    viewType = VK_IMAGE_VIEW_TYPE_2D
    format = VK_FORMAT_B8G8R8A8_UNORM
    components = 0x47f14d8
    subresourceRange = 0x47f14e8
     subresourceRange:
      aspectMask = 0x1
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1
     components:
      r = VK_COMPONENT_SWIZZLE_IDENTITY
      g = VK_COMPONENT_SWIZZLE_IDENTITY
      b = VK_COMPONENT_SWIZZLE_IDENTITY
      a = VK_COMPONENT_SWIZZLE_IDENTITY

t{0} f{0} vkCreateImageView(device = 0x49d66f8, pCreateInfo = 0x47f1508, pAlloca
tor = 0x0, *pView = 0x6dce00) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    image = 0x48327a0
    viewType = VK_IMAGE_VIEW_TYPE_2D
    format = VK_FORMAT_B8G8R8A8_UNORM
    components = 0x47f1528
    subresourceRange = 0x47f1538
     subresourceRange:
      aspectMask = 0x1
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1
     components:
      r = VK_COMPONENT_SWIZZLE_IDENTITY
      g = VK_COMPONENT_SWIZZLE_IDENTITY
      b = VK_COMPONENT_SWIZZLE_IDENTITY
      a = VK_COMPONENT_SWIZZLE_IDENTITY

t{0} f{0} vkCreateImageView(device = 0x49d66f8, pCreateInfo = 0x47f1558, pAlloca
tor = 0x0, *pView = 0x6dcd90) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    image = 0x48328b8
    viewType = VK_IMAGE_VIEW_TYPE_2D
    format = VK_FORMAT_B8G8R8A8_UNORM
    components = 0x47f1578
    subresourceRange = 0x47f1588
     subresourceRange:
      aspectMask = 0x1
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1
     components:
      r = VK_COMPONENT_SWIZZLE_IDENTITY
      g = VK_COMPONENT_SWIZZLE_IDENTITY
      b = VK_COMPONENT_SWIZZLE_IDENTITY
      a = VK_COMPONENT_SWIZZLE_IDENTITY

t{0} f{0} vkGetPhysicalDeviceFormatProperties(physicalDevice = 0x49e7640, format
 = VK_FORMAT_D32_SFLOAT, pFormatProperties = 0x20f59c)
   pFormatProperties:
    linearTilingFeatures = 0xd401
    optimalTilingFeatures = 0xd601
    bufferFeatures = 0x0

t{0} f{0} vkCreateRenderPass(device = 0x49d66f8, pCreateInfo = 0x20f848, pAlloca
tor = 0x0, *pRenderPass = 0x3f85ee8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    attachmentCount = 0x2
    pAttachments = 0x20f874
    subpassCount = 0x1
    pSubpasses = 0x20f8e8
    dependencyCount = 0x1
    pDependencies = 0x20f8c4
     pDependencies[0]:
      srcSubpass = 4294967295
      dstSubpass = 0
      srcStageMask = 0x400
      dstStageMask = 0x400
      srcAccessMask = 0x0
      dstAccessMask = 0x180
      dependencyFlags = 0x0
     pSubpasses[0]:
      flags = 0x0
      pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS
      inputAttachmentCount = 0x0
      pInputAttachments = 0x0
      colorAttachmentCount = 0x1
      pColorAttachments = 0x20f928
      pResolveAttachments = 0x0
      pDepthStencilAttachment = 0x20f918
      preserveAttachmentCount = 0x0
      pPreserveAttachments = 0x0
       pDepthStencilAttachment:
        attachment = 1
        layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
       pColorAttachments[0]:
        attachment = 0
        layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
     pAttachments[0]:
      flags = 0x0
      format = VK_FORMAT_B8G8R8A8_UNORM
      samples = VK_SAMPLE_COUNT_1_BIT
      loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR
      storeOp = VK_ATTACHMENT_STORE_OP_STORE
      stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE
      stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE
      initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
      finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
     pAttachments[1]:
      flags = 0x0
      format = VK_FORMAT_D32_SFLOAT
      samples = VK_SAMPLE_COUNT_1_BIT
      loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR
      storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE
      stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE
      stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE
      initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
      finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL

t{0} f{0} vkCreateDescriptorSetLayout(device = 0x49d66f8, pCreateInfo = 0x49ef98
8, pAllocator = 0x0, *pSetLayout = 0x6cbfc0) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    bindingCount = 0x2
    pBindings = 0x49d2294
     pBindings[0]:
      binding = 0
      descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
      descriptorCount = 0x1
      stageFlags = 0x1
      pImmutableSamplers = 0x0
     pBindings[1]:
      binding = 1
      descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
      descriptorCount = 0x1
      stageFlags = 0x10
      pImmutableSamplers = 0x0

t{0} f{0} vkCreateShaderModule(device = 0x49d66f8, pCreateInfo = 0x20f20c, pAllo
cator = 0x0, *pShaderModule = 0x454f518) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    codeSize = 0x640
    pCode = 0x73c448

t{0} f{0} vkCreateShaderModule(device = 0x49d66f8, pCreateInfo = 0x20f20c, pAllo
cator = 0x0, *pShaderModule = 0x454f758) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    codeSize = 0x2b4
    pCode = 0x4840720

t{0} f{0} vkCreatePipelineLayout(device = 0x49d66f8, pCreateInfo = 0x49e23c8, pA
llocator = 0x0, *pPipelineLayout = 0x73e0a8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    setLayoutCount = 0x1
    pSetLayouts = 0x48ad240
    pushConstantRangeCount = 0x0
    pPushConstantRanges = 0x0
     pSetLayouts[0] = 0x6cbfc0

t{0} f{0} vkCreateGraphicsPipelines(device = 0x49d66f8, pipelineCache = 0x0, cre
ateInfoCount = 0x1, pCreateInfos = 0x6dcd24, pAllocator = 0x0, *pPipelines = 0x4
811970) = VK_SUCCESS
   pCreateInfos[0]:
    sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    stageCount = 0x2
    pStages = 0x47f1a5c
    pVertexInputState = 0x49e1630
    pInputAssemblyState = 0x49ef788
    pTessellationState = 0x0
    pViewportState = 0x49e26e8
    pRasterizationState = 0x6c4b20
    pMultisampleState = 0x49dc348
    pDepthStencilState = 0x3f858d0
    pColorBlendState = 0x49d18f0
    pDynamicState = 0x0
    layout = 0x73e0a8
    renderPass = 0x3f85ee8
    subpass = 0
    basePipelineHandle = 0x0
    basePipelineIndex = 0x0
     pColorBlendState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      logicOpEnable = FALSE
      logicOp = VK_LOGIC_OP_COPY
      attachmentCount = 0x1
      pAttachments = 0x49e0000
      blendConstants = 0x49d190c
       blendConstants[0] = 0
       blendConstants[1] = 0
       blendConstants[2] = 0
       blendConstants[3] = 0
       pAttachments[0]:
        blendEnable = FALSE
        srcColorBlendFactor = VK_BLEND_FACTOR_ZERO
        dstColorBlendFactor = VK_BLEND_FACTOR_ZERO
        colorBlendOp = VK_BLEND_OP_ADD
        srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO
        dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO
        alphaBlendOp = VK_BLEND_OP_ADD
        colorWriteMask = 0xf
     pDepthStencilState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      depthTestEnable = TRUE
      depthWriteEnable = TRUE
      depthCompareOp = VK_COMPARE_OP_LESS
      depthBoundsTestEnable = FALSE
      stencilTestEnable = FALSE
      front = 0x3f858f0
      back = 0x3f8590c
      minDepthBounds = 0
      maxDepthBounds = 1
       back:
        failOp = VK_STENCIL_OP_KEEP
        passOp = VK_STENCIL_OP_KEEP
        depthFailOp = VK_STENCIL_OP_KEEP
        compareOp = VK_COMPARE_OP_NEVER
        compareMask = 0x0
        writeMask = 0x0
        reference = 0
       front:
        failOp = VK_STENCIL_OP_KEEP
        passOp = VK_STENCIL_OP_KEEP
        depthFailOp = VK_STENCIL_OP_KEEP
        compareOp = VK_COMPARE_OP_NEVER
        compareMask = 0x0
        writeMask = 0x0
        reference = 0
     pMultisampleState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      rasterizationSamples = VK_SAMPLE_COUNT_1_BIT
      sampleShadingEnable = FALSE
      minSampleShading = 1
      pSampleMask = 0x0
      alphaToCoverageEnable = FALSE
      alphaToOneEnable = FALSE
     pRasterizationState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      depthClampEnable = FALSE
      rasterizerDiscardEnable = FALSE
      polygonMode = VK_POLYGON_MODE_FILL
      cullMode = 0x2
      frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE
      depthBiasEnable = FALSE
      depthBiasConstantFactor = 0
      depthBiasClamp = 0
      depthBiasSlopeFactor = 0
      lineWidth = 1
     pViewportState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      viewportCount = 0x1
      pViewports = 0x49ef9a8
      scissorCount = 0x1
      pScissors = 0x47f25b8
       pScissors[0]:
        offset = 0x47f25b8
        extent = 0x47f25c0
         extent:
          width = 800
          height = 600
         offset:
          x = 0
          y = 0
       pViewports[0]:
        x = 0
        y = 0
        width = 800
        height = 600
        minDepth = 0
        maxDepth = 1
     pInputAssemblyState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
      primitiveRestartEnable = FALSE
     pVertexInputState:
      sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      vertexBindingDescriptionCount = 0x1
      pVertexBindingDescriptions = 0x47f25a0
      vertexAttributeDescriptionCount = 0x3
      pVertexAttributeDescriptions = 0x49d17a0
       pVertexAttributeDescriptions[0]:
        location = 0
        binding = 0
        format = VK_FORMAT_R32G32B32_SFLOAT
        offset = 0x0
       pVertexAttributeDescriptions[1]:
        location = 1
        binding = 0
        format = VK_FORMAT_R32G32B32_SFLOAT
        offset = 0xc
       pVertexAttributeDescriptions[2]:
        location = 2
        binding = 0
        format = VK_FORMAT_R32G32_SFLOAT
        offset = 0x18
       pVertexBindingDescriptions[0]:
        binding = 0
        stride = 32
        inputRate = VK_VERTEX_INPUT_RATE_VERTEX
     pStages[0]:
      sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      stage = VK_SHADER_STAGE_VERTEX_BIT
      module = 0x454f518
      pName = main
      pSpecializationInfo = 0x0
     pStages[1]:
      sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
      pNext = 0x0
      flags = 0x0
      stage = VK_SHADER_STAGE_FRAGMENT_BIT
      module = 0x454f758
      pName = main
      pSpecializationInfo = 0x0

t{0} f{0} vkDestroyShaderModule(device = 0x49d66f8, shaderModule = 0x454f758, pA
llocator = 0x0)
t{0} f{0} vkDestroyShaderModule(device = 0x49d66f8, shaderModule = 0x454f518, pA
llocator = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x0)
t{0} f{0} vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice = 0x49e7640, *
pQueueFamilyPropertyCount = 0x2, pQueueFamilyProperties = 0x47ec398)
   pQueueFamilyProperties:
    queueFlags = 0xf
    queueCount = 0x10
    timestampValidBits = 0x40
    minImageTransferGranularity = 0x47ec3a4
     minImageTransferGranularity:
      width = 1
      height = 1
      depth = 1

t{0} f{0} vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice = 0x49e7640, queue
FamilyIndex = 0x0, surface = 0x6d80a8, pSupported = 0020F7D8) = VK_SUCCESS
t{0} f{0} vkCreateCommandPool(device = 0x49d66f8, pCreateInfo = 0x20f96c, pAlloc
ator = 0x0, *pCommandPool = 0x49f4738) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    queueFamilyIndex = 0x0

t{0} f{0} vkGetPhysicalDeviceFormatProperties(physicalDevice = 0x49e7640, format
 = VK_FORMAT_D32_SFLOAT, pFormatProperties = 0x20f6f0)
   pFormatProperties:
    linearTilingFeatures = 0xd401
    optimalTilingFeatures = 0xd601
    bufferFeatures = 0x0

t{0} f{0} vkCreateImage(device = 0x49d66f8, pCreateInfo = 0x20f838, pAllocator =
 0x0, *pImage = 0x48329d0) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    imageType = VK_IMAGE_TYPE_2D
    format = VK_FORMAT_D32_SFLOAT
    extent = 0x20f84c
    mipLevels = 1
    arrayLayers = 1
    samples = VK_SAMPLE_COUNT_1_BIT
    tiling = VK_IMAGE_TILING_OPTIMAL
    usage = 0x20
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0
    initialLayout = VK_IMAGE_LAYOUT_PREINITIALIZED
     extent:
      width = 800
      height = 600
      depth = 1

t{0} f{0} vkGetImageMemoryRequirements(device = 0x49d66f8, image = 0x48329d0, pM
emoryRequirements = 0x20f818)
   pMemoryRequirements:
    size = 0x21b480
    alignment = 0x400
    memoryTypeBits = 0x110

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f4d4)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f4d8
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f5dc
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f7f8, pAlloca
tor = 0x0, *pMemory = 0x6dcd20) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x21b480
    memoryTypeIndex = 0x8

t{0} f{0} vkGetImageMemoryRequirements(device = 0x49d66f8, image = 0x48329d0, pM
emoryRequirements = 0x20f5e0)
   pMemoryRequirements:
    size = 0x21b480
    alignment = 0x400
    memoryTypeBits = 0x110

t{0} f{0} vkBindImageMemory(device = 0x49d66f8, image = 0x48329d0, memory = 0x6d
cd20, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkCreateImageView(device = 0x49d66f8, pCreateInfo = 0x47f1a58, pAlloca
tor = 0x0, *pView = 0x6dca10) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    image = 0x48329d0
    viewType = VK_IMAGE_VIEW_TYPE_2D
    format = VK_FORMAT_D32_SFLOAT
    components = 0x47f1a78
    subresourceRange = 0x47f1a88
     subresourceRange:
      aspectMask = 0x2
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1
     components:
      r = VK_COMPONENT_SWIZZLE_IDENTITY
      g = VK_COMPONENT_SWIZZLE_IDENTITY
      b = VK_COMPONENT_SWIZZLE_IDENTITY
      a = VK_COMPONENT_SWIZZLE_IDENTITY

t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49eee08
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x1

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x3f8d570
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x1
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdPipelineBarrier(commandBuffer = 0x546e848, srcStageMask = 0x1, ds
tStageMask = 0x1, dependencyFlags = 0x0, memoryBarrierCount = 0x0, pMemoryBarrie
rs = 0x0, bufferMemoryBarrierCount = 0x0, pBufferMemoryBarriers = 0x0, imageMemo
ryBarrierCount = 0x1, pImageMemoryBarriers = 0x47f19bc)
   pImageMemoryBarriers[0]:
    sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
    pNext = 0x0
    srcAccessMask = 0x0
    dstAccessMask = 0x600
    oldLayout = VK_IMAGE_LAYOUT_UNDEFINED
    newLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
    srcQueueFamilyIndex = 0xffffffff
    dstQueueFamilyIndex = 0xffffffff
    image = 0x48329d0
    subresourceRange = 0x47f19e4
     subresourceRange:
      aspectMask = 0x2
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1

t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da69
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x0
    pWaitSemaphores = 0x0
    pWaitDstStageMask = 0x0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5351070
    signalSemaphoreCount = 0x0
    pSignalSemaphores = 0x0
     pCommandBuffers[0] = 0x546e848

t{0} f{0} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{0} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, comm
andBufferCount = 0x1, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
t{0} f{0} vkCreateFramebuffer(device = 0x49d66f8, pCreateInfo = 0x49d18f0, pAllo
cator = 0x0, *pFramebuffer = 0x47f19b8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    renderPass = 0x3f85ee8
    attachmentCount = 0x2
    pAttachments = 0x3f8d570
    width = 800
    height = 600
    layers = 1
     pAttachments[0] = 0x6dce70
     pAttachments[1] = 0x6dca10

t{0} f{0} vkCreateFramebuffer(device = 0x49d66f8, pCreateInfo = 0x49d1f48, pAllo
cator = 0x0, *pFramebuffer = 0x47f1738) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    renderPass = 0x3f85ee8
    attachmentCount = 0x2
    pAttachments = 0x3f8d4c8
    width = 800
    height = 600
    layers = 1
     pAttachments[0] = 0x6dce00
     pAttachments[1] = 0x6dca10

t{0} f{0} vkCreateFramebuffer(device = 0x49d66f8, pCreateInfo = 0x49d17a0, pAllo
cator = 0x0, *pFramebuffer = 0x47f1698) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    renderPass = 0x3f85ee8
    attachmentCount = 0x2
    pAttachments = 0x3f8d510
    width = 800
    height = 600
    layers = 1
     pAttachments[0] = 0x6dcd90
     pAttachments[1] = 0x6dca10

t{0} f{0} vkCreateBuffer(device = 0x49d66f8, pCreateInfo = 0x20f7e8, pAllocator
= 0x0, *pBuffer = 0x707f78) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    size = 0x4000000
    usage = 0x1
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f7c8)
   pMemoryRequirements:
    size = 0x4000000
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f484)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f488
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f58c
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f7a8, pAlloca
tor = 0x0, *pMemory = 0x6dcaf0) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x4000000
    memoryTypeIndex = 0x9

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f578)
   pMemoryRequirements:
    size = 0x4000000
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkBindBufferMemory(device = 0x49d66f8, buffer = 0x707f78, memory = 0x6
dcaf0, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkMapMemory(device = 0x49d66f8, memory = 0x6dcaf0, offset = 0x0, size
= 0x4000000, flags = 0x0, *ppData = 0x10030000) = VK_SUCCESS
t{0} f{0} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcaf0)
t{0} f{0} vkCreateImage(device = 0x49d66f8, pCreateInfo = 0x20f7c4, pAllocator =
 0x0, *pImage = 0x48333a8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    imageType = VK_IMAGE_TYPE_2D
    format = VK_FORMAT_R8G8B8A8_UNORM
    extent = 0x20f7d8
    mipLevels = 1
    arrayLayers = 1
    samples = VK_SAMPLE_COUNT_1_BIT
    tiling = VK_IMAGE_TILING_OPTIMAL
    usage = 0x6
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0
    initialLayout = VK_IMAGE_LAYOUT_PREINITIALIZED
     extent:
      width = 4096
      height = 4096
      depth = 1

t{0} f{0} vkGetImageMemoryRequirements(device = 0x49d66f8, image = 0x48333a8, pM
emoryRequirements = 0x20f7a4)
   pMemoryRequirements:
    size = 0x4000000
    alignment = 0x400
    memoryTypeBits = 0x102

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f460)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f464
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f568
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f784, pAlloca
tor = 0x0, *pMemory = 0x6dcb60) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x4000000
    memoryTypeIndex = 0x8

t{0} f{0} vkGetImageMemoryRequirements(device = 0x49d66f8, image = 0x48333a8, pM
emoryRequirements = 0x20f56c)
   pMemoryRequirements:
    size = 0x4000000
    alignment = 0x400
    memoryTypeBits = 0x102

t{0} f{0} vkBindImageMemory(device = 0x49d66f8, image = 0x48333a8, memory = 0x6d
cb60, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49ee608
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x1

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x47e82a8
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x1
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdPipelineBarrier(commandBuffer = 0x546e848, srcStageMask = 0x1, ds
tStageMask = 0x1, dependencyFlags = 0x0, memoryBarrierCount = 0x0, pMemoryBarrie
rs = 0x0, bufferMemoryBarrierCount = 0x0, pBufferMemoryBarriers = 0x0, imageMemo
ryBarrierCount = 0x1, pImageMemoryBarriers = 0x47f196c)
   pImageMemoryBarriers[0]:
    sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
    pNext = 0x0
    srcAccessMask = 0x0
    dstAccessMask = 0x1000
    oldLayout = VK_IMAGE_LAYOUT_UNDEFINED
    newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
    srcQueueFamilyIndex = 0xffffffff
    dstQueueFamilyIndex = 0xffffffff
    image = 0x48333a8
    subresourceRange = 0x47f1994
     subresourceRange:
      aspectMask = 0x1
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1

t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da5d
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x0
    pWaitSemaphores = 0x0
    pWaitDstStageMask = 0x0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5351020
    signalSemaphoreCount = 0x0
    pSignalSemaphores = 0x0
     pCommandBuffers[0] = 0x546e848

t{0} f{0} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{0} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, comm
andBufferCount = 0x1, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49ee608
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x1

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x47e8440
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x1
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdCopyBufferToImage(commandBuffer = 0x546e848, srcBuffer = 0x707f78
, dstImage = 0x48333a8, dstImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, r
egionCount = 0x1, pRegions = 0x20f7cc)
   pRegions[0]:
    bufferOffset = 0x0
    bufferRowLength = 0x0
    bufferImageHeight = 0x0
    imageSubresource = 0x20f7dc
    imageOffset = 0x20f7ec
    imageExtent = 0x20f7f8
     imageExtent:
      width = 4096
      height = 4096
      depth = 1
     imageOffset:
      x = 0
      y = 0
      z = 0
     imageSubresource:
      aspectMask = 0x1
      mipLevel = 0
      baseArrayLayer = 0
      layerCount = 0x1

t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da5d
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x0
    pWaitSemaphores = 0x0
    pWaitDstStageMask = 0x0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5351010
    signalSemaphoreCount = 0x0
    pSignalSemaphores = 0x0
     pCommandBuffers[0] = 0x546e848

t{0} f{0} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{0} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, comm
andBufferCount = 0x1, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49ee608
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x1

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x47e82d8
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x1
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdPipelineBarrier(commandBuffer = 0x546e848, srcStageMask = 0x1, ds
tStageMask = 0x1, dependencyFlags = 0x0, memoryBarrierCount = 0x0, pMemoryBarrie
rs = 0x0, bufferMemoryBarrierCount = 0x0, pBufferMemoryBarriers = 0x0, imageMemo
ryBarrierCount = 0x1, pImageMemoryBarriers = 0x47f196c)
   pImageMemoryBarriers[0]:
    sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
    pNext = 0x0
    srcAccessMask = 0x1000
    dstAccessMask = 0x20
    oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
    newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
    srcQueueFamilyIndex = 0xffffffff
    dstQueueFamilyIndex = 0xffffffff
    image = 0x48333a8
    subresourceRange = 0x47f1994
     subresourceRange:
      aspectMask = 0x1
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1

t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da5d
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x0
    pWaitSemaphores = 0x0
    pWaitDstStageMask = 0x0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5351020
    signalSemaphoreCount = 0x0
    pSignalSemaphores = 0x0
     pCommandBuffers[0] = 0x546e848

t{0} f{0} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{0} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, comm
andBufferCount = 0x1, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
t{0} f{0} vkDestroyBuffer(device = 0x49d66f8, buffer = 0x707f78, pAllocator = 0x
0)
t{0} f{0} vkFreeMemory(device = 0x49d66f8, memory = 0x6dcaf0, pAllocator = 0x0)
t{0} f{0} vkCreateImageView(device = 0x49d66f8, pCreateInfo = 0x47f1968, pAlloca
tor = 0x0, *pView = 0x6dcaf0) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    image = 0x48333a8
    viewType = VK_IMAGE_VIEW_TYPE_2D
    format = VK_FORMAT_R8G8B8A8_UNORM
    components = 0x47f1988
    subresourceRange = 0x47f1998
     subresourceRange:
      aspectMask = 0x1
      baseMipLevel = 0
      levelCount = 0x1
      baseArrayLayer = 0
      layerCount = 0x1
     components:
      r = VK_COMPONENT_SWIZZLE_IDENTITY
      g = VK_COMPONENT_SWIZZLE_IDENTITY
      b = VK_COMPONENT_SWIZZLE_IDENTITY
      a = VK_COMPONENT_SWIZZLE_IDENTITY

t{0} f{0} vkCreateSampler(device = 0x49d66f8, pCreateInfo = 0x20f944, pAllocator
 = 0x0, *pSampler = 0x3f859a0) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    magFilter = VK_FILTER_LINEAR
    minFilter = VK_FILTER_LINEAR
    mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR
    addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT
    addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT
    addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT
    mipLodBias = 0
    anisotropyEnable = TRUE
    maxAnisotropy = 16
    compareEnable = FALSE
    compareOp = VK_COMPARE_OP_ALWAYS
    minLod = 0
    maxLod = 0
    borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK
    unnormalizedCoordinates = FALSE

t{0} f{0} vkCreateBuffer(device = 0x49d66f8, pCreateInfo = 0x20f82c, pAllocator
= 0x0, *pBuffer = 0x707f78) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    size = 0x81b5a0
    usage = 0x1
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f80c)
   pMemoryRequirements:
    size = 0x81b600
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f4c8)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f4cc
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f5d0
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f7ec, pAlloca
tor = 0x0, *pMemory = 0x6dcc40) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x81b600
    memoryTypeIndex = 0x9

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f5bc)
   pMemoryRequirements:
    size = 0x81b600
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkBindBufferMemory(device = 0x49d66f8, buffer = 0x707f78, memory = 0x6
dcc40, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0x81b5a0, flags = 0x0, *ppData = 0xcac0a00) = VK_SUCCESS
t{0} f{0} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{0} vkCreateBuffer(device = 0x49d66f8, pCreateInfo = 0x20f82c, pAllocator
= 0x0, *pBuffer = 0x707d38) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    size = 0x81b5a0
    usage = 0x82
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707d38, p
MemoryRequirements = 0x20f80c)
   pMemoryRequirements:
    size = 0x81b600
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f4c8)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f4cc
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f5d0
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f7ec, pAlloca
tor = 0x0, *pMemory = 0x6dccb0) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x81b600
    memoryTypeIndex = 0x7

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707d38, p
MemoryRequirements = 0x20f5bc)
   pMemoryRequirements:
    size = 0x81b600
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkBindBufferMemory(device = 0x49d66f8, buffer = 0x707d38, memory = 0x6
dccb0, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49ee3a8
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x1

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x47e8368
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x1
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdCopyBuffer(commandBuffer = 0x546e848, srcBuffer = 0x707f78, dstBu
ffer = 0x707d38, regionCount = 0x1, pRegions = 0x20f830)
   pRegions[0]:
    srcOffset = 0x0
    dstOffset = 0x0
    size = 0x81b5a0

t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da57
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x0
    pWaitSemaphores = 0x0
    pWaitDstStageMask = 0x0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5351000
    signalSemaphoreCount = 0x0
    pSignalSemaphores = 0x0
     pCommandBuffers[0] = 0x546e848

t{0} f{0} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{0} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, comm
andBufferCount = 0x1, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
t{0} f{0} vkDestroyBuffer(device = 0x49d66f8, buffer = 0x707f78, pAllocator = 0x
0)
t{0} f{0} vkFreeMemory(device = 0x49d66f8, memory = 0x6dcc40, pAllocator = 0x0)
t{0} f{0} vkCreateBuffer(device = 0x49d66f8, pCreateInfo = 0x20f82c, pAllocator
= 0x0, *pBuffer = 0x707f78) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    size = 0x5b8d80
    usage = 0x1
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f80c)
   pMemoryRequirements:
    size = 0x5b8e00
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f4c8)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f4cc
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f5d0
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f7ec, pAlloca
tor = 0x0, *pMemory = 0x6dcc40) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x5b8e00
    memoryTypeIndex = 0x9

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f5bc)
   pMemoryRequirements:
    size = 0x5b8e00
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkBindBufferMemory(device = 0x49d66f8, buffer = 0x707f78, memory = 0x6
dcc40, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0x5b8d80, flags = 0x0, *ppData = 0xb3d0200) = VK_SUCCESS
t{0} f{0} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{0} vkCreateBuffer(device = 0x49d66f8, pCreateInfo = 0x20f82c, pAllocator
= 0x0, *pBuffer = 0x707ca8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    size = 0x5b8d80
    usage = 0x42
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707ca8, p
MemoryRequirements = 0x20f80c)
   pMemoryRequirements:
    size = 0x5b8e00
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f4c8)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f4cc
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f5d0
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f7ec, pAlloca
tor = 0x0, *pMemory = 0x5341020) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x5b8e00
    memoryTypeIndex = 0x7

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707ca8, p
MemoryRequirements = 0x20f5bc)
   pMemoryRequirements:
    size = 0x5b8e00
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkBindBufferMemory(device = 0x49d66f8, buffer = 0x707ca8, memory = 0x5
341020, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49ee268
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x1

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x47e8368
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x1
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdCopyBuffer(commandBuffer = 0x546e848, srcBuffer = 0x707f78, dstBu
ffer = 0x707ca8, regionCount = 0x1, pRegions = 0x20f830)
   pRegions[0]:
    srcOffset = 0x0
    dstOffset = 0x0
    size = 0x5b8d80

t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da54
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x0
    pWaitSemaphores = 0x0
    pWaitDstStageMask = 0x0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ff0
    signalSemaphoreCount = 0x0
    pSignalSemaphores = 0x0
     pCommandBuffers[0] = 0x546e848

t{0} f{0} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{0} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, comm
andBufferCount = 0x1, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
t{0} f{0} vkDestroyBuffer(device = 0x49d66f8, buffer = 0x707f78, pAllocator = 0x
0)
t{0} f{0} vkFreeMemory(device = 0x49d66f8, memory = 0x6dcc40, pAllocator = 0x0)
t{0} f{0} vkCreateBuffer(device = 0x49d66f8, pCreateInfo = 0x20f858, pAllocator
= 0x0, *pBuffer = 0x707f78) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    size = 0xc0
    usage = 0x10
    sharingMode = VK_SHARING_MODE_EXCLUSIVE
    queueFamilyIndexCount = 0x0
    pQueueFamilyIndices = 0x0

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f838)
   pMemoryRequirements:
    size = 0x100
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkGetPhysicalDeviceMemoryProperties(physicalDevice = 0x49e7640, pMemor
yProperties = 0x20f4f4)
   pMemoryProperties:
    memoryTypeCount = 0xb
    memoryTypes = 0x20f4f8
    memoryHeapCount = 0x2
    memoryHeaps = 0x20f5fc
     memoryHeaps[0]:
      size = 0x7c540000
      flags = 0x1
     memoryHeaps[1]:
      size = 0x1dee00000
      flags = 0x0
     memoryHeaps[2]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[3]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[4]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[5]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[6]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[7]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[8]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[9]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[10]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[11]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[12]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[13]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[14]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryHeaps[15]:
      size = 0xcccccccccccccccc
      flags = 0xcccccccc
     memoryTypes[0]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[1]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[2]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[3]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[4]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[5]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[6]:
      propertyFlags = 0x0
      heapIndex = 0x1
     memoryTypes[7]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[8]:
      propertyFlags = 0x1
      heapIndex = 0x0
     memoryTypes[9]:
      propertyFlags = 0x6
      heapIndex = 0x1
     memoryTypes[10]:
      propertyFlags = 0xe
      heapIndex = 0x1
     memoryTypes[11]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[12]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[13]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[14]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[15]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[16]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[17]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[18]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[19]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[20]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[21]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[22]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[23]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[24]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[25]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[26]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[27]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[28]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[29]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[30]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc
     memoryTypes[31]:
      propertyFlags = 0xcccccccc
      heapIndex = 0xcccccccc

t{0} f{0} vkAllocateMemory(device = 0x49d66f8, pAllocateInfo = 0x20f818, pAlloca
tor = 0x0, *pMemory = 0x6dcc40) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    pNext = 0x0
    allocationSize = 0x100
    memoryTypeIndex = 0x9

t{0} f{0} vkGetBufferMemoryRequirements(device = 0x49d66f8, buffer = 0x707f78, p
MemoryRequirements = 0x20f5e8)
   pMemoryRequirements:
    size = 0x100
    alignment = 0x100
    memoryTypeBits = 0x681

t{0} f{0} vkBindBufferMemory(device = 0x49d66f8, buffer = 0x707f78, memory = 0x6
dcc40, memoryOffset = 0x0) = VK_SUCCESS
t{0} f{0} vkCreateDescriptorPool(device = 0x49d66f8, pCreateInfo = 0x20f958, pAl
locator = 0x0, *pDescriptorPool = 0x5341090) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
    pNext = 0x0
    flags = 0x0
    maxSets = 1
    poolSizeCount = 0x2
    pPoolSizes = 0x20f978
     pPoolSizes[0]:
      type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
      descriptorCount = 0x1
     pPoolSizes[1]:
      type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
      descriptorCount = 0x1

t{0} f{0} vkAllocateDescriptorSets(device = 0x49d66f8, pAllocateInfo = 0x49ee188
, *pDescriptorSets = 0x73b7e0) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
    pNext = 0x0
    descriptorPool = 0x5341090
    descriptorSetCount = 0x1
    pSetLayouts = 0x5350fe0
     pSetLayouts[0] = 0x6cbfc0

t{0} f{0} vkUpdateDescriptorSets(device = 0x49d66f8, descriptorWriteCount = 0x2,
 pDescriptorWrites = 0x5341104, descriptorCopyCount = 0x0, pDescriptorCopies = 0
x0)
   pDescriptorWrites[0]:
    sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
    pNext = 0x0
    dstSet = 0x73b7e0
    dstBinding = 0
    dstArrayElement = 0
    descriptorCount = 0x1
    descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
    pImageInfo = 0x0
    pBufferInfo = 0x49ee108
    pTexelBufferView = 0x0
     pBufferInfo[0]:
      buffer = 0x707f78
      offset = 0x0
      range = 0xc0

   pDescriptorWrites[1]:
    sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
    pNext = 0x0
    dstSet = 0x73b7e0
    dstBinding = 1
    dstArrayElement = 0
    descriptorCount = 0x1
    descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
    pImageInfo = 0x49ee0e8
    pBufferInfo = 0x0
    pTexelBufferView = 0x0
     pImageInfo[0]:
      sampler = 0x3f859a0
      imageView = 0x6dcaf0
      imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL

t{0} f{0} vkAllocateCommandBuffers(device = 0x49d66f8, pAllocateInfo = 0x49ee108
, *pCommandBuffers = 0x546e848) = VK_SUCCESS
   pAllocateInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    pNext = 0x0
    commandPool = 0x49f4738
    level = VK_COMMAND_BUFFER_LEVEL_PRIMARY
    commandBufferCount = 0x3

t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0x546e848, pBeginInfo = 0x47e84d0
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x4
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdBeginRenderPass(commandBuffer = 0x546e848, pRenderPassBegin = 0x4
9d2568, contents = VK_SUBPASS_CONTENTS_INLINE)
   pRenderPassBegin:
    sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
    pNext = 0x0
    renderPass = 0x3f85ee8
    framebuffer = 0x47f19b8
    renderArea = 0x49d2580
    clearValueCount = 0x2
    pClearValues = 0x49e1d60
     pClearValues[0]:
      color = 0x49e1d60
      depthStencil = 0x49e1d60
       depthStencil:
        depth = 0
        stencil = 0
       color:
        float32 = 0x49e1d60
        int32 = 0x49e1d60
        uint32 = 0x49e1d60
         uint32[0] = 0
         uint32[1] = 0
         uint32[2] = 0
         uint32[3] = 1065353216
         int32[0] = 0
         int32[1] = 0
         int32[2] = 0
         int32[3] = 1065353216
         float32[0] = 0
         float32[1] = 0
         float32[2] = 0
         float32[3] = 1
     pClearValues[1]:
      color = 0x49e1d70
      depthStencil = 0x49e1d70
       depthStencil:
        depth = 1
        stencil = 0
       color:
        float32 = 0x49e1d70
        int32 = 0x49e1d70
        uint32 = 0x49e1d70
         uint32[0] = 1065353216
         uint32[1] = 0
         uint32[2] = 0
         uint32[3] = 0
         int32[0] = 1065353216
         int32[1] = 0
         int32[2] = 0
         int32[3] = 0
         float32[0] = 1
         float32[1] = 0
         float32[2] = 0
         float32[3] = 0
     renderArea:
      offset = 0x49d2580
      extent = 0x49d2588
       extent:
        width = 800
        height = 600
       offset:
        x = 0
        y = 0

t{0} f{0} vkCmdBindPipeline(commandBuffer = 0x546e848, pipelineBindPoint = VK_PI
PELINE_BIND_POINT_GRAPHICS, pipeline = 0x4811970)
t{0} f{0} vkCmdBindVertexBuffers(commandBuffer = 0x546e848, firstBinding = 0x0,
bindingCount = 0x1, *pBuffers = 0x707d38, *pOffsets = 0x0)
t{0} f{0} vkCmdBindIndexBuffer(commandBuffer = 0x546e848, buffer = 0x707ca8, off
set = 0x0, indexType = VK_INDEX_TYPE_UINT32)
t{0} f{0} vkCmdBindDescriptorSets(commandBuffer = 0x546e848, pipelineBindPoint =
 VK_PIPELINE_BIND_POINT_GRAPHICS, layout = 0x73e0a8, firstSet = 0x0, descriptorS
etCount = 0x1, *pDescriptorSets = 0x73b7e0, dynamicOffsetCount = 0x0, pDynamicOf
fsets = 0x0)
   pDescriptorSets[0] = 0x73b7e0
t{0} f{0} vkCmdDrawIndexed(commandBuffer = 0x546e848, indexCount = 0x16e360, ins
tanceCount = 0x1, firstIndex = 0x0, vertexOffset = 0x0, firstInstance = 0x0)
t{0} f{0} vkCmdEndRenderPass(commandBuffer = 0x546e848)
t{0} f{0} vkEndCommandBuffer(commandBuffer = 0x546e848) = VK_SUCCESS
t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0xddd0c48, pBeginInfo = 0x47e8578
) = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x4
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdBeginRenderPass(commandBuffer = 0xddd0c48, pRenderPassBegin = 0x4
9d2568, contents = VK_SUBPASS_CONTENTS_INLINE)
   pRenderPassBegin:
    sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
    pNext = 0x0
    renderPass = 0x3f85ee8
    framebuffer = 0x47f1738
    renderArea = 0x49d2580
    clearValueCount = 0x2
    pClearValues = 0x49e2648
     pClearValues[0]:
      color = 0x49e2648
      depthStencil = 0x49e2648
       depthStencil:
        depth = 0
        stencil = 0
       color:
        float32 = 0x49e2648
        int32 = 0x49e2648
        uint32 = 0x49e2648
         uint32[0] = 0
         uint32[1] = 0
         uint32[2] = 0
         uint32[3] = 1065353216
         int32[0] = 0
         int32[1] = 0
         int32[2] = 0
         int32[3] = 1065353216
         float32[0] = 0
         float32[1] = 0
         float32[2] = 0
         float32[3] = 1
     pClearValues[1]:
      color = 0x49e2658
      depthStencil = 0x49e2658
       depthStencil:
        depth = 1
        stencil = 0
       color:
        float32 = 0x49e2658
        int32 = 0x49e2658
        uint32 = 0x49e2658
         uint32[0] = 1065353216
         uint32[1] = 0
         uint32[2] = 0
         uint32[3] = 0
         int32[0] = 1065353216
         int32[1] = 0
         int32[2] = 0
         int32[3] = 0
         float32[0] = 1
         float32[1] = 0
         float32[2] = 0
         float32[3] = 0
     renderArea:
      offset = 0x49d2580
      extent = 0x49d2588
       extent:
        width = 800
        height = 600
       offset:
        x = 0
        y = 0

t{0} f{0} vkCmdBindPipeline(commandBuffer = 0xddd0c48, pipelineBindPoint = VK_PI
PELINE_BIND_POINT_GRAPHICS, pipeline = 0x4811970)
t{0} f{0} vkCmdBindVertexBuffers(commandBuffer = 0xddd0c48, firstBinding = 0x0,
bindingCount = 0x1, *pBuffers = 0x707d38, *pOffsets = 0x0)
t{0} f{0} vkCmdBindIndexBuffer(commandBuffer = 0xddd0c48, buffer = 0x707ca8, off
set = 0x0, indexType = VK_INDEX_TYPE_UINT32)
t{0} f{0} vkCmdBindDescriptorSets(commandBuffer = 0xddd0c48, pipelineBindPoint =
 VK_PIPELINE_BIND_POINT_GRAPHICS, layout = 0x73e0a8, firstSet = 0x0, descriptorS
etCount = 0x1, *pDescriptorSets = 0x73b7e0, dynamicOffsetCount = 0x0, pDynamicOf
fsets = 0x0)
   pDescriptorSets[0] = 0x73b7e0
t{0} f{0} vkCmdDrawIndexed(commandBuffer = 0xddd0c48, indexCount = 0x16e360, ins
tanceCount = 0x1, firstIndex = 0x0, vertexOffset = 0x0, firstInstance = 0x0)
t{0} f{0} vkCmdEndRenderPass(commandBuffer = 0xddd0c48)
t{0} f{0} vkEndCommandBuffer(commandBuffer = 0xddd0c48) = VK_SUCCESS
t{0} f{0} vkBeginCommandBuffer(commandBuffer = 0xbc00c48, pBeginInfo = 0x73ce28)
 = VK_SUCCESS
   pBeginInfo:
    sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    pNext = 0x0
    flags = 0x4
    pInheritanceInfo = 0x0

t{0} f{0} vkCmdBeginRenderPass(commandBuffer = 0xbc00c48, pRenderPassBegin = 0x4
9d2568, contents = VK_SUBPASS_CONTENTS_INLINE)
   pRenderPassBegin:
    sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
    pNext = 0x0
    renderPass = 0x3f85ee8
    framebuffer = 0x47f1698
    renderArea = 0x49d2580
    clearValueCount = 0x2
    pClearValues = 0x49dfba0
     pClearValues[0]:
      color = 0x49dfba0
      depthStencil = 0x49dfba0
       depthStencil:
        depth = 0
        stencil = 0
       color:
        float32 = 0x49dfba0
        int32 = 0x49dfba0
        uint32 = 0x49dfba0
         uint32[0] = 0
         uint32[1] = 0
         uint32[2] = 0
         uint32[3] = 1065353216
         int32[0] = 0
         int32[1] = 0
         int32[2] = 0
         int32[3] = 1065353216
         float32[0] = 0
         float32[1] = 0
         float32[2] = 0
         float32[3] = 1
     pClearValues[1]:
      color = 0x49dfbb0
      depthStencil = 0x49dfbb0
       depthStencil:
        depth = 1
        stencil = 0
       color:
        float32 = 0x49dfbb0
        int32 = 0x49dfbb0
        uint32 = 0x49dfbb0
         uint32[0] = 1065353216
         uint32[1] = 0
         uint32[2] = 0
         uint32[3] = 0
         int32[0] = 1065353216
         int32[1] = 0
         int32[2] = 0
         int32[3] = 0
         float32[0] = 1
         float32[1] = 0
         float32[2] = 0
         float32[3] = 0
     renderArea:
      offset = 0x49d2580
      extent = 0x49d2588
       extent:
        width = 800
        height = 600
       offset:
        x = 0
        y = 0

t{0} f{0} vkCmdBindPipeline(commandBuffer = 0xbc00c48, pipelineBindPoint = VK_PI
PELINE_BIND_POINT_GRAPHICS, pipeline = 0x4811970)
t{0} f{0} vkCmdBindVertexBuffers(commandBuffer = 0xbc00c48, firstBinding = 0x0,
bindingCount = 0x1, *pBuffers = 0x707d38, *pOffsets = 0x0)
t{0} f{0} vkCmdBindIndexBuffer(commandBuffer = 0xbc00c48, buffer = 0x707ca8, off
set = 0x0, indexType = VK_INDEX_TYPE_UINT32)
t{0} f{0} vkCmdBindDescriptorSets(commandBuffer = 0xbc00c48, pipelineBindPoint =
 VK_PIPELINE_BIND_POINT_GRAPHICS, layout = 0x73e0a8, firstSet = 0x0, descriptorS
etCount = 0x1, *pDescriptorSets = 0x73b7e0, dynamicOffsetCount = 0x0, pDynamicOf
fsets = 0x0)
   pDescriptorSets[0] = 0x73b7e0
t{0} f{0} vkCmdDrawIndexed(commandBuffer = 0xbc00c48, indexCount = 0x16e360, ins
tanceCount = 0x1, firstIndex = 0x0, vertexOffset = 0x0, firstInstance = 0x0)
t{0} f{0} vkCmdEndRenderPass(commandBuffer = 0xbc00c48)
t{0} f{0} vkEndCommandBuffer(commandBuffer = 0xbc00c48) = VK_SUCCESS
t{0} f{0} vkCreateSemaphore(device = 0x49d66f8, pCreateInfo = 0x20f980, pAllocat
or = 0x0, *pSemaphore = 0x47f1c78) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
    pNext = 0x0
    flags = 0x0

t{0} f{0} vkCreateSemaphore(device = 0x49d66f8, pCreateInfo = 0x20f980, pAllocat
or = 0x0, *pSemaphore = 0x47f1cb8) = VK_SUCCESS
   pCreateInfo:
    sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
    pNext = 0x0
    flags = 0x0

t{0} f{0} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{0} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{0} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0)
 = VK_SUCCESS
t{0} f{0} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da12
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{0} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{1} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{1} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{1} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{1} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1)
 = VK_SUCCESS
t{0} f{1} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0f
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{1} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{2} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{2} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{2} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{2} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2)
 = VK_SUCCESS
t{0} f{2} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{2} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{3} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{3} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{3} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{3} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0)
 = VK_SUCCESS
t{0} f{3} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{3} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{4} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{4} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{4} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{4} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1)
 = VK_SUCCESS
t{0} f{4} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{4} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{5} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{5} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{5} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{5} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2)
 = VK_SUCCESS
t{0} f{5} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{5} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{6} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{6} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{6} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{6} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0)
 = VK_SUCCESS
t{0} f{6} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{6} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{7} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{7} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{7} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{7} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1)
 = VK_SUCCESS
t{0} f{7} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{7} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{8} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{8} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{8} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{8} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2)
 = VK_SUCCESS
t{0} f{8} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{8} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{9} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{9} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
= 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{9} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{9} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, timeo
ut = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0)
 = VK_SUCCESS
t{0} f{9} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0c
c, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{9} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SUC
CESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{10} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{10} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{10} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{10} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{10} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{10} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{11} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{11} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{11} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{11} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{11} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{11} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{12} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{12} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{12} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{12} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{12} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{12} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{13} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{13} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{13} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{13} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{13} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{13} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{14} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{14} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{14} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{14} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{14} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{14} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{15} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{15} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{15} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{15} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{15} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{15} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{16} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{16} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{16} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{16} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{16} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{16} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{17} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{17} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{17} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{17} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{17} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{17} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{18} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{18} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{18} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{18} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{18} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{18} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{19} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{19} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{19} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{19} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{19} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{19} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{20} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{20} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{20} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{20} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{20} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{20} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{21} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{21} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{21} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{21} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{21} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{21} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{22} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{22} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{22} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{22} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{22} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{22} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{23} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{23} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{23} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{23} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{23} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{23} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{24} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{24} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{24} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{24} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{24} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{24} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{25} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{25} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{25} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{25} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{25} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{25} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{26} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{26} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{26} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{26} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{26} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{26} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{27} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{27} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{27} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{27} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{27} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{27} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{28} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{28} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{28} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{28} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{28} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{28} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{29} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{29} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{29} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{29} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{29} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{29} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{30} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{30} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{30} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{30} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{30} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{30} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{31} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{31} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{31} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{31} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{31} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{31} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{32} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{32} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{32} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{32} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{32} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{32} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{33} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{33} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{33} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{33} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{33} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{33} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{34} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{34} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{34} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{34} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{34} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{34} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{35} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{35} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{35} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{35} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{35} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{35} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{36} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{36} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{36} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{36} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{36} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{36} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{37} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{37} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{37} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{37} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{37} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{37} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{38} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{38} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{38} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{38} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{38} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{38} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{39} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{39} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{39} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{39} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{39} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{39} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{40} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{40} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{40} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{40} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{40} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{40} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{41} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{41} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{41} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{41} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{41} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{41} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{42} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{42} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{42} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{42} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{42} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{42} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{43} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{43} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{43} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{43} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{43} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{43} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{44} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{44} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{44} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{44} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{44} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{44} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{45} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{45} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{45} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{45} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{45} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{45} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{46} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{46} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{46} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{46} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{46} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{46} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{47} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{47} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{47} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{47} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{47} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{47} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{48} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{48} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{48} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{48} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{48} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{48} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{49} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{49} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{49} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{49} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{49} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{49} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{50} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{50} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{50} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{50} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{50} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{50} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{51} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{51} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{51} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{51} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{51} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{51} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{52} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{52} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{52} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{52} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{52} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{52} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{53} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{53} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{53} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{53} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{53} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{53} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{54} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{54} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{54} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{54} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{54} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{54} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{55} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{55} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{55} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{55} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{55} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{55} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{56} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{56} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{56} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{56} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{56} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{56} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{57} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{57} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{57} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{57} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{57} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{57} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{58} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{58} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{58} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{58} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{58} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{58} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{59} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{59} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{59} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{59} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{59} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{59} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{60} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{60} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{60} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{60} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{60} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    pWaitDstStageMask = 0x5350f10
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e50
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{60} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    swapchainCount = 0x1
    pSwapchains = 0x5350e50
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{61} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{61} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{61} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{61} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{61} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    pWaitDstStageMask = 0x5350ed0
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f10
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f40
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{61} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f40
    swapchainCount = 0x1
    pSwapchains = 0x5350f10
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{62} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{62} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{62} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{62} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{62} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    pWaitDstStageMask = 0x5350e30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350ed0
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f30
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{62} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfa60) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f30
    swapchainCount = 0x1
    pSwapchains = 0x5350ed0
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{63} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{63} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{63} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{63} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x0
) = VK_SUCCESS
t{0} f{63} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    pWaitDstStageMask = 0x5350f40
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350e30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350e50
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0x546e848
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{63} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e0fa0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e50
    swapchainCount = 0x1
    pSwapchains = 0x5350e30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x0
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{64} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{64} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{64} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{64} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x1
) = VK_SUCCESS
t{0} f{64} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    pWaitDstStageMask = 0x5350f30
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f40
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350f10
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xddd0c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{64} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49dfba0) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350f10
    swapchainCount = 0x1
    pSwapchains = 0x5350f40
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x1
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{65} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{65} vkMapMemory(device = 0x49d66f8, memory = 0x6dcc40, offset = 0x0, size
 = 0xc0, flags = 0x0, *ppData = 0x632be00) = VK_SUCCESS
t{0} f{65} vkUnmapMemory(device = 0x49d66f8, memory = 0x6dcc40)
t{0} f{65} vkAcquireNextImageKHR(device = 0x49d66f8, swapchain = 0x4801bb0, time
out = 0xffffffffffffffff, semaphore = 0x47f1c78, fence = 0x0, *pImageIndex = 0x2
) = VK_SUCCESS
t{0} f{65} vkQueueSubmit(queue = 0x6cc0e0, submitCount = 0x1, pSubmits = 0x49da0
cc, fence = 0x0) = VK_SUCCESS
   pSubmits[0]:
    sType = VK_STRUCTURE_TYPE_SUBMIT_INFO
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350e30
    pWaitDstStageMask = 0x5350e50
    commandBufferCount = 0x1
    pCommandBuffers = 0x5350f30
    signalSemaphoreCount = 0x1
    pSignalSemaphores = 0x5350ed0
     pSignalSemaphores[0] = 0x47f1cb8
     pCommandBuffers[0] = 0xbc00c48
     pWaitSemaphores[0] = 0x47f1c78

t{0} f{65} vkQueuePresentKHR(queue = 0x6cc0e0, pPresentInfo = 0x49e12e8) = VK_SU
CCESS
   pPresentInfo:
    sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
    pNext = 0x0
    waitSemaphoreCount = 0x1
    pWaitSemaphores = 0x5350ed0
    swapchainCount = 0x1
    pSwapchains = 0x5350f30
    pImageIndices = 0x20f988
    pResults = NULL
     pImageIndices[0] = 0x2
     pSwapchains[0] = 0x4801bb0
     pWaitSemaphores[0] = 0x47f1cb8

t{0} f{66} vkQueueWaitIdle(queue = 0x6cc0e0) = VK_SUCCESS
t{0} f{66} vkDeviceWaitIdle(device = 0x49d66f8) = VK_SUCCESS
t{0} f{66} vkDestroyImageView(device = 0x49d66f8, imageView = 0x6dca10, pAllocat
or = 0x0)
t{0} f{66} vkDestroyImage(device = 0x49d66f8, image = 0x48329d0, pAllocator = 0x
0)
t{0} f{66} vkFreeMemory(device = 0x49d66f8, memory = 0x6dcd20, pAllocator = 0x0)

t{0} f{66} vkDestroyFramebuffer(device = 0x49d66f8, framebuffer = 0x47f19b8, pAl
locator = 0x0)
t{0} f{66} vkDestroyFramebuffer(device = 0x49d66f8, framebuffer = 0x47f1738, pAl
locator = 0x0)
t{0} f{66} vkDestroyFramebuffer(device = 0x49d66f8, framebuffer = 0x47f1698, pAl
locator = 0x0)
t{0} f{66} vkFreeCommandBuffers(device = 0x49d66f8, commandPool = 0x49f4738, com
mandBufferCount = 0x3, *pCommandBuffers = 0x546e848)
   pCommandBuffers[0] = 0x546e848
   pCommandBuffers[1] = 0xddd0c48
   pCommandBuffers[2] = 0xbc00c48
t{0} f{66} vkDestroyPipeline(device = 0x49d66f8, pipeline = 0x4811970, pAllocato
r = 0x0)
t{0} f{66} vkDestroyPipelineLayout(device = 0x49d66f8, pipelineLayout = 0x73e0a8
, pAllocator = 0x0)
t{0} f{66} vkDestroyRenderPass(device = 0x49d66f8, renderPass = 0x3f85ee8, pAllo
cator = 0x0)
t{0} f{66} vkDestroyImageView(device = 0x49d66f8, imageView = 0x6dce70, pAllocat
or = 0x0)
t{0} f{66} vkDestroyImageView(device = 0x49d66f8, imageView = 0x6dce00, pAllocat
or = 0x0)
t{0} f{66} vkDestroyImageView(device = 0x49d66f8, imageView = 0x6dcd90, pAllocat
or = 0x0)
t{0} f{66} vkDestroySwapchainKHR(device = 0x49d66f8, swapchain = 0x4801bb0, pAll
ocator = 0x0)
t{0} f{66} vkDestroySampler(device = 0x49d66f8, sampler = 0x3f859a0, pAllocator
= 0x0)
t{0} f{66} vkDestroyImageView(device = 0x49d66f8, imageView = 0x6dcaf0, pAllocat
or = 0x0)
t{0} f{66} vkDestroyImage(device = 0x49d66f8, image = 0x48333a8, pAllocator = 0x
0)
t{0} f{66} vkFreeMemory(device = 0x49d66f8, memory = 0x6dcb60, pAllocator = 0x0)

t{0} f{66} vkDestroyDescriptorPool(device = 0x49d66f8, descriptorPool = 0x534109
0, pAllocator = 0x0)
t{0} f{66} vkDestroyDescriptorSetLayout(device = 0x49d66f8, descriptorSetLayout
= 0x6cbfc0, pAllocator = 0x0)
t{0} f{66} vkDestroyBuffer(device = 0x49d66f8, buffer = 0x707f78, pAllocator = 0
x0)
t{0} f{66} vkFreeMemory(device = 0x49d66f8, memory = 0x6dcc40, pAllocator = 0x0)

t{0} f{66} vkDestroyBuffer(device = 0x49d66f8, buffer = 0x707ca8, pAllocator = 0
x0)
t{0} f{66} vkFreeMemory(device = 0x49d66f8, memory = 0x5341020, pAllocator = 0x0
)
t{0} f{66} vkDestroyBuffer(device = 0x49d66f8, buffer = 0x707d38, pAllocator = 0
x0)
t{0} f{66} vkFreeMemory(device = 0x49d66f8, memory = 0x6dccb0, pAllocator = 0x0)

t{0} f{66} vkDestroySemaphore(device = 0x49d66f8, semaphore = 0x47f1cb8, pAlloca
tor = 0x0)
t{0} f{66} vkDestroySemaphore(device = 0x49d66f8, semaphore = 0x47f1c78, pAlloca
tor = 0x0)
t{0} f{66} vkDestroyCommandPool(device = 0x49d66f8, commandPool = 0x49f4738, pAl
locator = 0x0)
t{0} f{66} vkDestroyDevice(device = 0x49d66f8, pAllocator = 0x0)
t{0} f{66} vkDestroySurfaceKHR(instance = 0x71e868, surface = 0x6d80a8, pAllocat
or = 0x0)
t{0} f{66} vkDestroyInstance(instance = 0x71e868, pAllocator = 0x0)
Enter a character and press ENTER to exit
